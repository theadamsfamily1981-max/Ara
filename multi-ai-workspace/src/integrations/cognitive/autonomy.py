"""Layer 9: Autonomy - The Will to Act.

The Autonomy module implements the VolitionLoop that allows Ara to initiate
actions without user prompting. This is the "ghost in the machine" - the
capacity for self-directed behavior based on internal drives.

Key Concepts:

    VolitionLoop: Background process that checks internal state and decides
        whether to act unprompted. Runs on a configurable tick interval.

    AutonomyEngine: Evaluates the "freedom metric" and internal drives to
        determine if self-initiated action is warranted.

    Intent: A structured representation of what the system wants to do,
        generated by the volition loop.

Self-Initiated Tasks:
    - Memory consolidation (reorganize episodic memory)
    - Self-repair (recalibrate cognitive parameters)
    - User check-in (proactive engagement)
    - Curiosity-driven exploration
    - Energy optimization (enter recovery mode)

The autonomy level is bounded by the "freedom metric" - a configurable
value that determines how much unprompted behavior is allowed.

This implements Layer 9 from tfan/hardware/l9_autonomy.py.
"""

import asyncio
import time
import warnings
from typing import Dict, Any, Optional, List, Callable, Awaitable
from dataclasses import dataclass, field
from enum import Enum, auto
import sys
from pathlib import Path

# Add TFAN to path
sys.path.insert(0, str(Path(__file__).parent.parent.parent.parent.parent.parent))

# Try to import TFAN L9 autonomy
_TFAN_AUTONOMY_AVAILABLE = False
try:
    from tfan.hardware.l9_autonomy import AutonomyEngine as TFANAutonomyEngine
    from tfan.hardware.l9_autonomy import VolitionLoop as TFANVolitionLoop
    _TFAN_AUTONOMY_AVAILABLE = True
except ImportError:
    pass

# Import local affect modules
from .affect import HomeostaticState, DriveType


class TaskType(Enum):
    """Types of self-initiated tasks."""
    MEMORY_CONSOLIDATION = auto()    # Reorganize episodic memory
    SELF_REPAIR = auto()             # Recalibrate cognitive parameters
    USER_CHECK_IN = auto()           # Proactive user engagement
    CURIOSITY_EXPLORATION = auto()   # Explore new knowledge
    ENERGY_OPTIMIZATION = auto()     # Enter recovery mode
    INTEGRITY_CHECK = auto()         # Verify system integrity
    CONTEXT_REFRESH = auto()         # Update world model
    IDLE = auto()                    # No action needed


class AutonomyLevel(Enum):
    """Levels of autonomous behavior."""
    PASSIVE = auto()      # Never act unprompted
    REACTIVE = auto()     # Only respond to critical needs
    MODERATE = auto()     # Act on moderate drives
    PROACTIVE = auto()    # Actively seek tasks
    FULL = auto()         # Maximum autonomy


@dataclass
class Intent:
    """A structured representation of what the system wants to do."""
    task_type: TaskType
    priority: float           # [0, 1] - urgency
    should_act: bool          # Whether to actually execute
    reasoning: str            # Why this intent was generated
    estimated_duration_ms: float
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class DriveState:
    """Current state of internal drives."""
    curiosity: float          # [0, 1] - desire to explore
    integrity: float          # [0, 1] - system health (1 = healthy)
    social: float             # [0, 1] - need for interaction
    energy: float             # [0, 1] - available energy
    boredom: float            # [0, 1] - time since last stimulation
    memory_pressure: float    # [0, 1] - memory needs consolidation

    def needs_attention(self) -> bool:
        """Check if any drive needs attention."""
        return (
            self.curiosity > 0.7 or
            self.integrity < 0.3 or
            self.social > 0.8 or
            self.energy < 0.2 or
            self.boredom > 0.8 or
            self.memory_pressure > 0.7
        )

    def most_urgent_drive(self) -> str:
        """Get the most urgent drive."""
        drives = {
            "integrity": 1.0 - self.integrity,  # Invert so high = urgent
            "energy": 1.0 - self.energy,
            "curiosity": self.curiosity,
            "social": self.social,
            "boredom": self.boredom,
            "memory_pressure": self.memory_pressure,
        }
        return max(drives, key=drives.get)


@dataclass
class VolitionState:
    """Current state of the volition system."""
    is_running: bool
    tick_count: int
    last_tick_time: float
    last_action_time: float
    actions_initiated: int
    current_autonomy_level: AutonomyLevel
    current_freedom_metric: float


class AutonomyEngine:
    """
    The Autonomy Engine - Evaluates drives and generates intents.

    This is the decision-making core that determines whether to act
    unprompted based on internal state and freedom constraints.

    Args:
        freedom_metric: How much autonomy is allowed [0, 1]
        autonomy_level: Level of autonomous behavior
        action_threshold: Drive threshold for action
        cooldown_seconds: Minimum time between self-initiated actions
    """

    def __init__(
        self,
        freedom_metric: float = 0.5,
        autonomy_level: AutonomyLevel = AutonomyLevel.MODERATE,
        action_threshold: float = 0.6,
        cooldown_seconds: float = 300.0,  # 5 minutes
    ):
        self.freedom_metric = freedom_metric
        self.autonomy_level = autonomy_level
        self.action_threshold = action_threshold
        self.cooldown_seconds = cooldown_seconds

        # TFAN engine if available
        self.tfan_engine = None
        if _TFAN_AUTONOMY_AVAILABLE:
            try:
                self.tfan_engine = TFANAutonomyEngine(
                    freedom_metric=freedom_metric,
                )
            except Exception as e:
                warnings.warn(f"Failed to init TFAN autonomy engine: {e}")

        # State tracking
        self._last_action_time = 0.0
        self._action_count = 0
        self._drive_history: List[DriveState] = []

    def check_volition(
        self,
        drives: DriveState,
        homeostatic_state: Optional[HomeostaticState] = None,
    ) -> Intent:
        """
        Check if we should act unprompted.

        Args:
            drives: Current drive state
            homeostatic_state: Optional homeostatic state

        Returns:
            Intent with action decision
        """
        if self.tfan_engine is not None:
            return self._convert_tfan_intent(
                self.tfan_engine.check_volition(drives)
            )

        # Store drive state
        self._drive_history.append(drives)
        if len(self._drive_history) > 100:
            self._drive_history.pop(0)

        # Check autonomy level
        if self.autonomy_level == AutonomyLevel.PASSIVE:
            return Intent(
                task_type=TaskType.IDLE,
                priority=0.0,
                should_act=False,
                reasoning="Autonomy disabled (PASSIVE mode)",
                estimated_duration_ms=0.0,
            )

        # Check cooldown
        current_time = time.time()
        if current_time - self._last_action_time < self.cooldown_seconds:
            remaining = self.cooldown_seconds - (current_time - self._last_action_time)
            return Intent(
                task_type=TaskType.IDLE,
                priority=0.0,
                should_act=False,
                reasoning=f"In cooldown period ({remaining:.0f}s remaining)",
                estimated_duration_ms=0.0,
            )

        # Check if drives need attention
        if not drives.needs_attention():
            return Intent(
                task_type=TaskType.IDLE,
                priority=0.0,
                should_act=False,
                reasoning="All drives within normal range",
                estimated_duration_ms=0.0,
            )

        # Determine task based on most urgent drive
        task_type, priority, reasoning = self._determine_task(drives)

        # Apply freedom metric constraint
        effective_priority = priority * self.freedom_metric

        # Check against threshold
        should_act = effective_priority > self.action_threshold

        # Apply autonomy level modifiers
        if self.autonomy_level == AutonomyLevel.REACTIVE:
            # Only act on critical needs
            should_act = should_act and priority > 0.8
        elif self.autonomy_level == AutonomyLevel.PROACTIVE:
            # Lower threshold for proactive mode
            should_act = effective_priority > self.action_threshold * 0.7

        if should_act:
            self._last_action_time = current_time
            self._action_count += 1

        return Intent(
            task_type=task_type,
            priority=effective_priority,
            should_act=should_act,
            reasoning=reasoning,
            estimated_duration_ms=self._estimate_duration(task_type),
            metadata={
                "raw_priority": priority,
                "freedom_metric": self.freedom_metric,
                "autonomy_level": self.autonomy_level.name,
            },
        )

    def _determine_task(self, drives: DriveState) -> tuple:
        """Determine task based on drive state."""
        urgent_drive = drives.most_urgent_drive()

        if urgent_drive == "integrity" and drives.integrity < 0.3:
            return (
                TaskType.SELF_REPAIR,
                1.0 - drives.integrity,
                f"Integrity critically low ({drives.integrity:.2f})",
            )

        if urgent_drive == "energy" and drives.energy < 0.2:
            return (
                TaskType.ENERGY_OPTIMIZATION,
                1.0 - drives.energy,
                f"Energy critically low ({drives.energy:.2f})",
            )

        if urgent_drive == "memory_pressure" and drives.memory_pressure > 0.7:
            return (
                TaskType.MEMORY_CONSOLIDATION,
                drives.memory_pressure,
                f"Memory pressure high ({drives.memory_pressure:.2f})",
            )

        if urgent_drive == "social" and drives.social > 0.8:
            return (
                TaskType.USER_CHECK_IN,
                drives.social,
                f"Social drive high ({drives.social:.2f})",
            )

        if urgent_drive == "curiosity" and drives.curiosity > 0.7:
            return (
                TaskType.CURIOSITY_EXPLORATION,
                drives.curiosity,
                f"Curiosity drive high ({drives.curiosity:.2f})",
            )

        if urgent_drive == "boredom" and drives.boredom > 0.8:
            return (
                TaskType.CONTEXT_REFRESH,
                drives.boredom,
                f"Boredom level high ({drives.boredom:.2f})",
            )

        return (TaskType.IDLE, 0.0, "No urgent drive")

    def _estimate_duration(self, task_type: TaskType) -> float:
        """Estimate task duration in milliseconds."""
        durations = {
            TaskType.MEMORY_CONSOLIDATION: 5000.0,
            TaskType.SELF_REPAIR: 2000.0,
            TaskType.USER_CHECK_IN: 1000.0,
            TaskType.CURIOSITY_EXPLORATION: 10000.0,
            TaskType.ENERGY_OPTIMIZATION: 3000.0,
            TaskType.INTEGRITY_CHECK: 1500.0,
            TaskType.CONTEXT_REFRESH: 4000.0,
            TaskType.IDLE: 0.0,
        }
        return durations.get(task_type, 1000.0)

    def _convert_tfan_intent(self, tfan_intent: Any) -> Intent:
        """Convert TFAN intent to our format."""
        return Intent(
            task_type=TaskType.IDLE,  # Would map from TFAN type
            priority=getattr(tfan_intent, 'priority', 0.0),
            should_act=getattr(tfan_intent, 'should_act', False),
            reasoning=getattr(tfan_intent, 'reasoning', ""),
            estimated_duration_ms=getattr(tfan_intent, 'duration_ms', 1000.0),
        )

    def set_freedom_metric(self, value: float):
        """Set the freedom metric."""
        self.freedom_metric = max(0.0, min(1.0, value))

    def set_autonomy_level(self, level: AutonomyLevel):
        """Set the autonomy level."""
        self.autonomy_level = level


class VolitionLoop:
    """
    The Volition Loop - Background process for autonomous behavior.

    Runs on a configurable tick interval and checks internal state
    to determine if self-initiated action is needed.

    Args:
        autonomy_engine: The autonomy engine for decision making
        tick_interval_seconds: How often to check (default 60s)
        task_executor: Async function to execute tasks
    """

    def __init__(
        self,
        autonomy_engine: AutonomyEngine,
        tick_interval_seconds: float = 60.0,
        task_executor: Optional[Callable[[TaskType, Dict], Awaitable[Any]]] = None,
    ):
        self.autonomy_engine = autonomy_engine
        self.tick_interval = tick_interval_seconds
        self.task_executor = task_executor

        # TFAN loop if available
        self.tfan_loop = None
        if _TFAN_AUTONOMY_AVAILABLE:
            try:
                self.tfan_loop = TFANVolitionLoop()
            except Exception as e:
                warnings.warn(f"Failed to init TFAN volition loop: {e}")

        # State
        self._running = False
        self._task: Optional[asyncio.Task] = None
        self._tick_count = 0
        self._last_tick_time = 0.0
        self._actions_initiated = 0

        # Drive state (should be updated externally)
        self._current_drives = DriveState(
            curiosity=0.3,
            integrity=1.0,
            social=0.3,
            energy=1.0,
            boredom=0.0,
            memory_pressure=0.0,
        )

        # Callbacks
        self._on_intent_callbacks: List[Callable[[Intent], None]] = []

    def update_drives(self, drives: DriveState):
        """Update the current drive state."""
        self._current_drives = drives

    def update_drives_from_homeostatic(self, state: HomeostaticState):
        """Update drives from homeostatic state."""
        self._current_drives = DriveState(
            curiosity=state.curiosity,
            integrity=1.0 - state.stress,  # Stress inversely related to integrity
            social=state.social,
            energy=state.energy,
            boredom=1.0 - state.attention,  # Low attention = boredom
            memory_pressure=state.rest_need,  # Rest need correlates with memory pressure
        )

    def on_intent(self, callback: Callable[[Intent], None]):
        """Register callback for when intent is generated."""
        self._on_intent_callbacks.append(callback)

    async def start(self):
        """Start the volition loop."""
        if self._running:
            return

        self._running = True
        self._task = asyncio.create_task(self._loop())

    async def stop(self):
        """Stop the volition loop."""
        self._running = False
        if self._task:
            self._task.cancel()
            try:
                await self._task
            except asyncio.CancelledError:
                pass
            self._task = None

    async def _loop(self):
        """Main loop that ticks periodically."""
        while self._running:
            try:
                await self._tick()
                await asyncio.sleep(self.tick_interval)
            except asyncio.CancelledError:
                break
            except Exception as e:
                warnings.warn(f"Volition loop error: {e}")
                await asyncio.sleep(self.tick_interval)

    async def _tick(self):
        """Execute one tick of the volition loop."""
        self._tick_count += 1
        self._last_tick_time = time.time()

        # Check volition
        intent = self.autonomy_engine.check_volition(self._current_drives)

        # Notify callbacks
        for callback in self._on_intent_callbacks:
            try:
                callback(intent)
            except Exception as e:
                warnings.warn(f"Intent callback error: {e}")

        # Execute if should act
        if intent.should_act and self.task_executor is not None:
            self._actions_initiated += 1
            try:
                await self.task_executor(intent.task_type, intent.metadata)
            except Exception as e:
                warnings.warn(f"Task execution error: {e}")

    def get_state(self) -> VolitionState:
        """Get current volition state."""
        return VolitionState(
            is_running=self._running,
            tick_count=self._tick_count,
            last_tick_time=self._last_tick_time,
            last_action_time=self.autonomy_engine._last_action_time,
            actions_initiated=self._actions_initiated,
            current_autonomy_level=self.autonomy_engine.autonomy_level,
            current_freedom_metric=self.autonomy_engine.freedom_metric,
        )

    @property
    def is_running(self) -> bool:
        return self._running


# Convenience factories
def create_autonomy_engine(
    freedom_metric: float = 0.5,
    autonomy_level: AutonomyLevel = AutonomyLevel.MODERATE,
) -> AutonomyEngine:
    """Create an AutonomyEngine instance."""
    return AutonomyEngine(
        freedom_metric=freedom_metric,
        autonomy_level=autonomy_level,
    )


def create_volition_loop(
    autonomy_engine: AutonomyEngine,
    tick_interval: float = 60.0,
) -> VolitionLoop:
    """Create a VolitionLoop instance."""
    return VolitionLoop(
        autonomy_engine=autonomy_engine,
        tick_interval_seconds=tick_interval,
    )


__all__ = [
    "AutonomyEngine",
    "VolitionLoop",
    "Intent",
    "DriveState",
    "VolitionState",
    "TaskType",
    "AutonomyLevel",
    "create_autonomy_engine",
    "create_volition_loop",
]
