"""
Adaptive L3 Metacontrol Service

Makes the L3 control laws LEARNABLE via AEPO optimization.
The system learns how to manage its own emotions.

Key innovations:
1. AEPO tunes L3 knobs (jerk_threshold, controller_weight, etc.)
2. Parameters loaded from best.yaml generated by AEPO training
3. D-Bus L3PolicyUpdated signal for cockpit visualization
4. Hyperbolic geometry integration for valence computation

Control Law Parameters (learnable):
- jerk_threshold: Max allowed PAD change rate
- controller_weight: P-term weight for homeostatic correction
- arousal_to_temp_scale: Arousal → Temperature mapping
- valence_to_memory_scale: Valence → Memory multiplier mapping
- dominance_to_attention_scale: Dominance → Attention gain mapping
- curvature_c: Hyperbolic curvature for geometric control

Usage:
    from tfan.emotion.adaptive_controller import (
        AdaptiveMetacontrol,
        L3ControlParams,
        load_control_params_from_config,
    )

    # Load learned parameters
    params = load_control_params_from_config("configs/best.yaml")
    controller = AdaptiveMetacontrol(params)

    # Use in control loop
    output = controller.compute_control(valence, arousal, dominance, stability_gap)
"""

import json
import time
import logging
import threading
from dataclasses import dataclass, asdict, field
from typing import Optional, Dict, Any, List, Callable
from pathlib import Path
from datetime import datetime

import yaml

logger = logging.getLogger("tfan.emotion.adaptive_controller")

# D-Bus configuration
DBUS_BUS_NAME = "org.ara.metacontrol"
DBUS_INTERFACE = "org.ara.metacontrol.L3Interface"

# D-Bus availability
try:
    import dbus
    import dbus.service
    from dbus.mainloop.glib import DBusGMainLoop
    DBUS_AVAILABLE = True
except ImportError:
    DBUS_AVAILABLE = False
    dbus = None


@dataclass
class L3ControlParams:
    """
    Learnable L3 metacontrol parameters.

    These are tuned by AEPO to optimize system behavior.
    """
    # Jerk control (rate limiting)
    jerk_threshold: float = 0.1         # Max PAD change per step
    jerk_smoothing: float = 0.9         # Exponential smoothing factor

    # Homeostatic controller
    controller_weight: float = 0.5      # P-term weight
    integral_decay: float = 0.95        # I-term decay
    max_integral: float = 1.0           # Max accumulated error

    # PAD → Control mapping scales
    arousal_to_temp_scale: float = 0.5      # Arousal → Temperature
    arousal_to_temp_offset: float = 0.8     # Base temperature
    valence_to_memory_scale: float = 0.25   # Valence → Memory
    valence_to_memory_offset: float = 0.95  # Base memory
    dominance_to_attention_scale: float = 0.4  # Dominance → Attention
    dominance_to_attention_offset: float = 0.8 # Base attention

    # Hyperbolic geometry
    curvature_c: float = 1.0            # Poincaré ball curvature
    boundary_penalty_weight: float = 0.1
    stability_penalty_weight: float = 2.0

    # Safety bounds
    min_temperature: float = 0.1
    max_temperature: float = 2.0
    min_memory: float = 0.5
    max_memory: float = 1.5
    min_attention: float = 0.5
    max_attention: float = 1.5

    # Suppression thresholds
    suppress_arousal_threshold: float = 0.9
    suppress_valence_threshold: float = -0.8
    suppress_stability_threshold: float = 0.5

    # Version tracking
    version: str = "1.0"
    trained_at: str = ""
    training_episodes: int = 0

    def to_dict(self) -> Dict[str, Any]:
        return asdict(self)

    @classmethod
    def from_dict(cls, d: Dict[str, Any]) -> "L3ControlParams":
        valid_fields = set(cls.__dataclass_fields__.keys())
        filtered = {k: v for k, v in d.items() if k in valid_fields}
        return cls(**filtered)


@dataclass
class L3ControlOutput:
    """Output from L3 metacontrol computation."""
    temperature_mult: float = 1.0
    memory_mult: float = 1.0
    attention_gain: float = 1.0
    needs_suppression: bool = False
    jerk_limited: bool = False
    geometric_valence: float = 0.0
    timestamp: str = ""

    def to_dict(self) -> Dict[str, Any]:
        return asdict(self)


def load_control_params_from_config(config_path: str) -> L3ControlParams:
    """
    Load L3 control parameters from AEPO-generated config.

    Args:
        config_path: Path to best.yaml or similar config

    Returns:
        L3ControlParams with learned values
    """
    path = Path(config_path)

    if not path.exists():
        logger.warning(f"Config not found: {config_path}, using defaults")
        return L3ControlParams()

    with open(path) as f:
        config = yaml.safe_load(f)

    # Extract L3 params from config
    params = L3ControlParams()

    # Look for l3_params section
    l3_section = config.get("l3_params", config.get("metacontrol", {}))

    if l3_section:
        for key, value in l3_section.items():
            if hasattr(params, key):
                setattr(params, key, value)

    # Extract training metadata
    training = config.get("training", {})
    params.trained_at = config.get("generated_at", "")
    params.training_episodes = training.get("episodes", 0)

    logger.info(f"Loaded L3 params from {config_path}")

    return params


class AdaptiveMetacontrol:
    """
    Adaptive L3 Metacontrol with learnable control laws.

    Computes control signals using AEPO-optimized parameters.
    Supports D-Bus signaling for external integration.
    """

    def __init__(
        self,
        params: L3ControlParams = None,
        enable_dbus: bool = False,
    ):
        """
        Initialize adaptive metacontrol.

        Args:
            params: L3 control parameters (learnable)
            enable_dbus: Whether to enable D-Bus signaling
        """
        self.params = params or L3ControlParams()
        self.enable_dbus = enable_dbus

        # State tracking
        self._prev_valence = 0.0
        self._prev_arousal = 0.5
        self._prev_dominance = 0.5
        self._error_integral = 0.0

        # Goal state (homeostatic target)
        self.goal_valence = 0.0
        self.goal_arousal = 0.5

        # D-Bus service
        self._dbus_thread = None
        self._policy_callbacks: List[Callable[[L3ControlParams], None]] = []

        logger.info(f"AdaptiveMetacontrol initialized (c={self.params.curvature_c})")

    def compute_control(
        self,
        valence: float,
        arousal: float,
        dominance: float = 0.5,
        stability_gap: float = 0.0,
        embeddings: Any = None,
    ) -> L3ControlOutput:
        """
        Compute L3 control output using learned parameters.

        Args:
            valence: Current PAD valence [-1, 1]
            arousal: Current PAD arousal [0, 1]
            dominance: Current PAD dominance [0, 1]
            stability_gap: L2 topology stability gap
            embeddings: Optional hyperbolic embeddings for geometric control

        Returns:
            L3ControlOutput with control multipliers
        """
        p = self.params
        jerk_limited = False

        # Jerk limiting (rate of change constraint)
        delta_v = valence - self._prev_valence
        delta_a = arousal - self._prev_arousal
        delta_d = dominance - self._prev_dominance

        max_delta = p.jerk_threshold
        if abs(delta_v) > max_delta or abs(delta_a) > max_delta:
            jerk_limited = True
            valence = self._prev_valence + max(-max_delta, min(max_delta, delta_v))
            arousal = self._prev_arousal + max(-max_delta, min(max_delta, delta_a))
            dominance = self._prev_dominance + max(-max_delta, min(max_delta, delta_d))

        # Update state
        self._prev_valence = valence
        self._prev_arousal = arousal
        self._prev_dominance = dominance

        # Homeostatic correction
        valence_error = self.goal_valence - valence
        arousal_error = self.goal_arousal - arousal

        self._error_integral = (
            p.integral_decay * self._error_integral +
            (valence_error + arousal_error) * 0.5
        )
        self._error_integral = max(-p.max_integral, min(p.max_integral, self._error_integral))

        correction = p.controller_weight * self._error_integral

        # PAD → Control mapping
        temperature = (
            p.arousal_to_temp_offset +
            p.arousal_to_temp_scale * arousal +
            correction * 0.1
        )

        memory = (
            p.valence_to_memory_offset +
            p.valence_to_memory_scale * (valence + 1) / 2 +
            correction * 0.1
        )

        attention = (
            p.dominance_to_attention_offset +
            p.dominance_to_attention_scale * dominance
        )

        # Stability-aware adjustment
        if stability_gap > 0.1:
            # High instability → reduce exploration
            temperature *= (1.0 - stability_gap * p.stability_penalty_weight * 0.1)

        # Hyperbolic geometry adjustment (if embeddings provided)
        geometric_valence = valence
        if embeddings is not None:
            try:
                from tfan.losses.hyperbolic_reg import compute_l3_valence_from_geometry
                geometric_valence = compute_l3_valence_from_geometry(
                    embeddings,
                    c=p.curvature_c,
                    stability_gap=stability_gap,
                )
                # Blend geometric and PAD valence
                valence = 0.5 * valence + 0.5 * geometric_valence
            except ImportError:
                pass

        # Apply safety bounds
        temperature = max(p.min_temperature, min(p.max_temperature, temperature))
        memory = max(p.min_memory, min(p.max_memory, memory))
        attention = max(p.min_attention, min(p.max_attention, attention))

        # Suppression decision
        needs_suppression = (
            arousal > p.suppress_arousal_threshold or
            valence < p.suppress_valence_threshold or
            stability_gap > p.suppress_stability_threshold
        )

        output = L3ControlOutput(
            temperature_mult=temperature,
            memory_mult=memory,
            attention_gain=attention,
            needs_suppression=needs_suppression,
            jerk_limited=jerk_limited,
            geometric_valence=geometric_valence,
            timestamp=datetime.utcnow().isoformat(),
        )

        return output

    def update_params(self, new_params: L3ControlParams):
        """
        Update control parameters (from AEPO optimization).

        Args:
            new_params: New learned parameters
        """
        self.params = new_params

        logger.info(f"L3 params updated (c={new_params.curvature_c})")

        # Notify callbacks
        for cb in self._policy_callbacks:
            try:
                cb(new_params)
            except Exception as e:
                logger.error(f"Policy callback error: {e}")

        # Emit D-Bus signal
        if self.enable_dbus and DBUS_AVAILABLE:
            self._emit_policy_updated()

    def on_policy_updated(self, callback: Callable[[L3ControlParams], None]):
        """Register callback for policy updates."""
        self._policy_callbacks.append(callback)

    def _emit_policy_updated(self):
        """Emit L3PolicyUpdated D-Bus signal."""
        # Implementation depends on D-Bus setup
        pass

    def set_goal(self, valence: float, arousal: float):
        """Set homeostatic goal state."""
        self.goal_valence = max(-1, min(1, valence))
        self.goal_arousal = max(0, min(1, arousal))

    def reset_state(self):
        """Reset internal state."""
        self._prev_valence = 0.0
        self._prev_arousal = 0.5
        self._prev_dominance = 0.5
        self._error_integral = 0.0

    def get_status(self) -> Dict[str, Any]:
        """Get controller status."""
        return {
            "params": self.params.to_dict(),
            "goal_valence": self.goal_valence,
            "goal_arousal": self.goal_arousal,
            "error_integral": self._error_integral,
            "dbus_enabled": self.enable_dbus,
        }


def generate_aepo_l3_action_space() -> Dict[str, Any]:
    """
    Generate AEPO action space that includes L3 control knobs.

    This extends the AEPO agent to tune L3 metacontrol parameters.

    Returns:
        Dict defining action space for L3 tuning
    """
    return {
        "l3_jerk_threshold": {
            "type": "continuous",
            "low": 0.01,
            "high": 0.3,
            "description": "Max PAD change rate",
        },
        "l3_controller_weight": {
            "type": "continuous",
            "low": 0.1,
            "high": 1.0,
            "description": "Homeostatic P-term weight",
        },
        "l3_arousal_scale": {
            "type": "continuous",
            "low": 0.1,
            "high": 1.0,
            "description": "Arousal → Temperature scale",
        },
        "l3_valence_scale": {
            "type": "continuous",
            "low": 0.1,
            "high": 0.5,
            "description": "Valence → Memory scale",
        },
        "l3_curvature_c": {
            "type": "continuous",
            "low": 0.1,
            "high": 2.0,
            "description": "Hyperbolic curvature",
        },
        "l3_suppress_arousal": {
            "type": "continuous",
            "low": 0.7,
            "high": 1.0,
            "description": "Arousal suppression threshold",
        },
    }


def apply_aepo_l3_action(
    params: L3ControlParams,
    action: Dict[str, float],
) -> L3ControlParams:
    """
    Apply AEPO action to L3 control parameters.

    Args:
        params: Current parameters
        action: Action dict from AEPO agent

    Returns:
        Updated L3ControlParams
    """
    new_params = L3ControlParams(**params.to_dict())

    if "l3_jerk_threshold" in action:
        new_params.jerk_threshold = action["l3_jerk_threshold"]
    if "l3_controller_weight" in action:
        new_params.controller_weight = action["l3_controller_weight"]
    if "l3_arousal_scale" in action:
        new_params.arousal_to_temp_scale = action["l3_arousal_scale"]
    if "l3_valence_scale" in action:
        new_params.valence_to_memory_scale = action["l3_valence_scale"]
    if "l3_curvature_c" in action:
        new_params.curvature_c = action["l3_curvature_c"]
    if "l3_suppress_arousal" in action:
        new_params.suppress_arousal_threshold = action["l3_suppress_arousal"]

    return new_params


# Exports
__all__ = [
    "AdaptiveMetacontrol",
    "L3ControlParams",
    "L3ControlOutput",
    "load_control_params_from_config",
    "generate_aepo_l3_action_space",
    "apply_aepo_l3_action",
    "DBUS_AVAILABLE",
]
