#version 450

/**
 * Quilt Compute Shader
 * ====================
 *
 * Renders N views (quiltCols x quiltRows) into a single quilt texture.
 * Each view is rendered from a camera positioned on a ring around the origin.
 *
 * The scene contains a simple ray-marched sphere that orbits over time.
 * Replace sampleRadiance() with your NeRF/radiance field sampler for real content.
 */

layout(local_size_x = 16, local_size_y = 16) in;

layout(rgba16f, binding = 0) uniform writeonly image2D quiltImage;

uniform int quiltCols;
uniform int quiltRows;
uniform int viewW;
uniform int viewH;
uniform float time;

const float PI = 3.14159265359;
const float FOV_Y = radians(60.0);

// =============================================================================
// Background gradient (simple sky)
// =============================================================================

vec3 backgroundColor(vec3 dir) {
    float t = 0.5 * (dir.y + 1.0);
    vec3 horizon = vec3(0.05, 0.05, 0.12);
    vec3 zenith = vec3(0.15, 0.25, 0.55);
    return mix(horizon, zenith, t);
}

// =============================================================================
// Sphere intersection
// =============================================================================

float intersectSphere(vec3 ro, vec3 rd, vec3 center, float radius) {
    vec3 oc = ro - center;
    float a = dot(rd, rd);
    float b = 2.0 * dot(oc, rd);
    float c = dot(oc, oc) - radius * radius;
    float disc = b * b - 4.0 * a * c;
    if (disc < 0.0) return -1.0;
    float sdisc = sqrt(disc);
    float t0 = (-b - sdisc) / (2.0 * a);
    float t1 = (-b + sdisc) / (2.0 * a);
    float t = t0;
    if (t < 0.0) t = t1;
    return t > 0.0 ? t : -1.0;
}

// =============================================================================
// Ground plane intersection (checkerboard pattern)
// =============================================================================

vec4 intersectPlane(vec3 ro, vec3 rd, float y) {
    if (abs(rd.y) < 0.001) return vec4(-1.0);
    float t = (y - ro.y) / rd.y;
    if (t < 0.0) return vec4(-1.0);

    vec3 p = ro + t * rd;

    // Checkerboard
    float scale = 2.0;
    int cx = int(floor(p.x * scale));
    int cz = int(floor(p.z * scale));
    float checker = mod(float(cx + cz), 2.0);

    vec3 baseColor = checker > 0.5 ? vec3(0.2, 0.2, 0.25) : vec3(0.3, 0.3, 0.35);

    // Fade with distance
    float fade = exp(-t * 0.1);
    baseColor *= fade;

    return vec4(baseColor, t);
}

// =============================================================================
// Main render function
// =============================================================================

vec3 renderScene(vec3 ro, vec3 rd) {
    vec3 color = backgroundColor(rd);

    // Animate sphere position
    vec3 sphereCenter = vec3(0.0, 0.8, 0.0);
    sphereCenter.x += 1.2 * sin(time * 0.7);
    sphereCenter.z += 1.2 * cos(time * 0.9);
    sphereCenter.y += 0.3 * sin(time * 1.3);

    float sphereRadius = 0.8;

    // Ground plane
    vec4 planeHit = intersectPlane(ro, rd, 0.0);
    float tPlane = planeHit.w;

    // Sphere
    float tSphere = intersectSphere(ro, rd, sphereCenter, sphereRadius);

    // Determine closest hit
    float tHit = -1.0;
    int hitType = 0; // 0=none, 1=sphere, 2=plane

    if (tSphere > 0.0 && (tPlane < 0.0 || tSphere < tPlane)) {
        tHit = tSphere;
        hitType = 1;
    } else if (tPlane > 0.0) {
        tHit = tPlane;
        hitType = 2;
    }

    if (hitType == 1) {
        // Sphere shading
        vec3 p = ro + tHit * rd;
        vec3 n = normalize(p - sphereCenter);

        // Animated light
        vec3 lightDir = normalize(vec3(
            0.6 + 0.2 * sin(time * 0.5),
            0.8,
            0.3 + 0.2 * cos(time * 0.4)
        ));

        float diff = max(dot(n, lightDir), 0.0);
        float rim = pow(1.0 - max(dot(n, -rd), 0.0), 3.0);

        // Cathedral colors: bluish with golden rim
        vec3 baseColor = vec3(0.15, 0.5, 0.85);
        vec3 rimColor = vec3(0.95, 0.8, 0.4);

        color = baseColor * (0.15 + 0.85 * diff) + rim * rimColor * 0.4;

        // Specular highlight
        vec3 h = normalize(lightDir - rd);
        float spec = pow(max(dot(n, h), 0.0), 64.0);
        color += vec3(1.0) * spec * 0.6;

    } else if (hitType == 2) {
        // Plane shading
        color = planeHit.rgb;

        // Add sphere shadow
        vec3 p = ro + tPlane * rd;
        vec3 lightDir = normalize(vec3(0.6, 0.8, 0.3));
        vec3 shadowRayOrigin = p + vec3(0.0, 0.001, 0.0);
        float shadowHit = intersectSphere(shadowRayOrigin, lightDir, sphereCenter, sphereRadius);
        if (shadowHit > 0.0) {
            color *= 0.4; // In shadow
        }
    }

    return color;
}

// =============================================================================
// Main compute entry point
// =============================================================================

void main() {
    ivec2 gid = ivec2(gl_GlobalInvocationID.xy);
    int quiltW = quiltCols * viewW;
    int quiltH = quiltRows * viewH;

    if (gid.x >= quiltW || gid.y >= quiltH) return;

    // Determine which view this pixel belongs to
    int view_x = gid.x / viewW;
    int view_y = gid.y / viewH;
    int view_id = view_y * quiltCols + view_x;

    // Local pixel within that view
    int px = gid.x % viewW;
    int py = gid.y % viewH;

    // NDC in [-1, 1]
    float nx = ((float(px) + 0.5) / float(viewW)) * 2.0 - 1.0;
    float ny = ((float(py) + 0.5) / float(viewH)) * 2.0 - 1.0;

    float aspect = float(viewW) / float(viewH);
    float tanHalfFov = tan(FOV_Y * 0.5);

    // Camera on a ring around the scene center
    // Views are distributed around the ring for parallax
    int totalViews = quiltCols * quiltRows;
    float viewAngle = 2.0 * PI * (float(view_id) / float(totalViews));

    // Camera parameters
    float cameraRadius = 4.5;
    float cameraHeight = 2.0;

    vec3 camPos = vec3(
        cameraRadius * cos(viewAngle),
        cameraHeight,
        cameraRadius * sin(viewAngle)
    );

    // Look at scene center (slightly elevated)
    vec3 target = vec3(0.0, 0.5, 0.0);
    vec3 forward = normalize(target - camPos);
    vec3 worldUp = vec3(0.0, 1.0, 0.0);
    vec3 right = normalize(cross(forward, worldUp));
    vec3 up = normalize(cross(right, forward));

    // Construct ray direction
    vec3 dir = normalize(
        forward +
        (nx * aspect * tanHalfFov) * right +
        (ny * tanHalfFov) * up
    );

    // Render
    vec3 color = renderScene(camPos, dir);

    // Gamma correction
    color = pow(color, vec3(1.0 / 2.2));

    imageStore(quiltImage, gid, vec4(color, 1.0));
}
