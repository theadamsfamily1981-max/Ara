#!/usr/bin/env python3
"""
Ara PCIe Driver Generator

Generates Linux kernel PCIe drivers from device manifests.

Usage:
    ./gen_pcie_driver.py manifest.json -o out/
    -> out/ara_<device_name>.c

The generated driver:
- Maps BARs based on manifest
- Sets up MSI-X vectors
- Provides basic probe/remove lifecycle
- Ready for DKMS or kernel tree integration
"""

from __future__ import annotations
import json
import argparse
from pathlib import Path
from string import Template
from dataclasses import dataclass, field
from typing import List, Dict, Optional, Any


# =============================================================================
# Device Manifest Schema
# =============================================================================

@dataclass
class BARConfig:
    """BAR configuration from manifest."""
    index: int
    size: int
    type: str  # "mmio" or "io"
    role: str  # "control", "dma_window", etc.
    prefetchable: bool = False


@dataclass
class MSIXConfig:
    """MSI-X configuration."""
    vectors: int
    q_pairs: int = 0
    table_bar: int = 0
    pba_bar: int = 0


@dataclass
class FeatureConfig:
    """DFH/DFL feature configuration."""
    name: str
    type: str  # "axi_dma", "xnor_cam", "control", etc.
    bar: int
    offset: int
    length: int
    version: str = "1.0"
    params: Dict[str, Any] = field(default_factory=dict)


@dataclass
class LinkConfig:
    """PCIe link configuration."""
    max_speed: str  # "gen1" - "gen6"
    max_width: int  # 1, 2, 4, 8, 16, 32
    target_speed: str = "gen4"
    target_width: int = 16


@dataclass
class DeviceManifest:
    """Complete device manifest."""
    name: str
    vendor_id: str
    device_id: str
    subsystem_vendor_id: str = "0x0000"
    subsystem_device_id: str = "0x0000"
    class_code: str = "0x000000"
    revision: str = "0x00"
    bars: List[BARConfig] = field(default_factory=list)
    msix: Optional[MSIXConfig] = None
    features: List[FeatureConfig] = field(default_factory=list)
    link: Optional[LinkConfig] = None

    @classmethod
    def from_json(cls, data: Dict) -> "DeviceManifest":
        """Parse manifest from JSON dict."""
        bars = [BARConfig(**b) for b in data.get("bars", [])]
        msix = MSIXConfig(**data["msix"]) if data.get("msix") else None
        features = [FeatureConfig(**f) for f in data.get("features", [])]
        link = LinkConfig(**data["link"]) if data.get("link") else None

        return cls(
            name=data["name"],
            vendor_id=data["vendor_id"],
            device_id=data["device_id"],
            subsystem_vendor_id=data.get("subsystem_vendor_id", "0x0000"),
            subsystem_device_id=data.get("subsystem_device_id", "0x0000"),
            class_code=data.get("class_code", "0x000000"),
            revision=data.get("revision", "0x00"),
            bars=bars,
            msix=msix,
            features=features,
            link=link,
        )


# =============================================================================
# Driver Template
# =============================================================================

DRV_TEMPLATE = Template(r"""// SPDX-License-Identifier: GPL-2.0
/*
 * Ara Auto-Generated PCIe Driver
 * Device: $NAME
 * Vendor: $VENDOR_ID, Device: $DEVICE_ID
 *
 * Generated by: banos/hw_autoint/gen_pcie_driver.py
 * DO NOT HAND-EDIT - regenerate from manifest instead.
 */

#include <linux/module.h>
#include <linux/pci.h>
#include <linux/io.h>
#include <linux/interrupt.h>
#include <linux/dma-mapping.h>

#define DRV_NAME "$C_NAME"
#define DRV_VERSION "1.0.0"

/* BAR definitions */
#define ARA_BAR_COUNT $BAR_COUNT
$BAR_DEFINES

/* Feature offsets */
$FEATURE_DEFINES

/* Device structure */
struct ara_pcie_bar {
    void __iomem *base;
    resource_size_t size;
    int index;
};

struct ara_pcie_dev {
    struct pci_dev *pdev;
    struct ara_pcie_bar bars[ARA_BAR_COUNT];
    int msix_vectors;
    int num_bars;

    /* Feature pointers */
$FEATURE_FIELDS
};

/* PCI ID table */
static const struct pci_device_id ara_pcie_id_table[] = {
    { PCI_DEVICE($VENDOR_ID, $DEVICE_ID) },
    { 0, }
};
MODULE_DEVICE_TABLE(pci, ara_pcie_id_table);

/* MSI-X interrupt handler */
static irqreturn_t ara_msix_handler(int irq, void *dev_id)
{
    struct ara_pcie_dev *adev = dev_id;

    /* TODO: Read status from control BAR, clear IRQ, schedule work */
    (void)adev;

    return IRQ_HANDLED;
}

/* Feature initialization */
$FEATURE_INIT_FUNCS

/* Probe function */
static int ara_pcie_probe(struct pci_dev *pdev, const struct pci_device_id *id)
{
    int err, i;
    struct ara_pcie_dev *adev;

    dev_info(&pdev->dev, "Ara driver probing %s\n", DRV_NAME);

    /* Enable device */
    err = pci_enable_device_mem(pdev);
    if (err) {
        dev_err(&pdev->dev, "Failed to enable device (%d)\n", err);
        return err;
    }

    /* Request memory regions */
    err = pci_request_mem_regions(pdev, DRV_NAME);
    if (err) {
        dev_err(&pdev->dev, "Failed to request regions (%d)\n", err);
        goto err_disable;
    }

    /* Enable bus mastering for DMA */
    pci_set_master(pdev);

    /* Set DMA mask */
    err = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));
    if (err) {
        err = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));
        if (err) {
            dev_err(&pdev->dev, "Failed to set DMA mask\n");
            goto err_regions;
        }
    }

    /* Allocate device structure */
    adev = devm_kzalloc(&pdev->dev, sizeof(*adev), GFP_KERNEL);
    if (!adev) {
        err = -ENOMEM;
        goto err_regions;
    }
    pci_set_drvdata(pdev, adev);
    adev->pdev = pdev;

    /* Map BARs */
$BAR_MAP_CODE

    /* Setup MSI-X */
$MSIX_SETUP_CODE

    /* Initialize features */
$FEATURE_INIT_CALLS

    dev_info(&pdev->dev, "Ara driver attached: %s (msix=%d, bars=%d)\n",
             DRV_NAME, adev->msix_vectors, adev->num_bars);
    return 0;

err_regions:
    pci_release_mem_regions(pdev);
err_disable:
    pci_disable_device(pdev);
    return err;
}

/* Remove function */
static void ara_pcie_remove(struct pci_dev *pdev)
{
    struct ara_pcie_dev *adev = pci_get_drvdata(pdev);
    int i;

    if (!adev)
        return;

    dev_info(&pdev->dev, "Ara driver removing %s\n", DRV_NAME);

    /* Free MSI-X */
    if (adev->msix_vectors > 0) {
        for (i = 0; i < adev->msix_vectors; i++) {
            int irq = pci_irq_vector(pdev, i);
            free_irq(irq, adev);
        }
        pci_free_irq_vectors(pdev);
    }

    /* Unmap BARs */
    for (i = 0; i < ARA_BAR_COUNT; i++) {
        if (adev->bars[i].base)
            iounmap(adev->bars[i].base);
    }

    pci_release_mem_regions(pdev);
    pci_disable_device(pdev);
}

/* Driver structure */
static struct pci_driver ara_pcie_driver = {
    .name     = DRV_NAME,
    .id_table = ara_pcie_id_table,
    .probe    = ara_pcie_probe,
    .remove   = ara_pcie_remove,
};

module_pci_driver(ara_pcie_driver);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Ara Autogen");
MODULE_DESCRIPTION("Ara auto-generated PCIe driver for $NAME");
MODULE_VERSION(DRV_VERSION);
""")


# =============================================================================
# Code Generation Helpers
# =============================================================================

def gen_bar_defines(bars: List[BARConfig]) -> str:
    """Generate BAR index defines."""
    lines = []
    for bar in bars:
        name = bar.role.upper()
        lines.append(f"#define ARA_BAR_{name} {bar.index}")
    return "\n".join(lines)


def gen_feature_defines(features: List[FeatureConfig]) -> str:
    """Generate feature offset defines."""
    lines = []
    for feat in features:
        name = feat.name.upper()
        lines.append(f"#define ARA_FEAT_{name}_BAR {feat.bar}")
        lines.append(f"#define ARA_FEAT_{name}_OFFSET 0x{feat.offset:x}")
        lines.append(f"#define ARA_FEAT_{name}_SIZE 0x{feat.length:x}")
    return "\n".join(lines)


def gen_feature_fields(features: List[FeatureConfig]) -> str:
    """Generate feature pointer fields in device struct."""
    lines = []
    for feat in features:
        lines.append(f"    void __iomem *{feat.name};  /* {feat.type} */")
    return "\n".join(lines)


def gen_bar_map_code(bars: List[BARConfig]) -> str:
    """Generate BAR mapping code."""
    lines = []
    for bar in bars:
        idx = bar.index
        lines.append(f"""
    /* Map BAR{idx} ({bar.role}) */
    adev->bars[{idx}].base = pci_ioremap_bar(pdev, {idx});
    if (!adev->bars[{idx}].base) {{
        dev_err(&pdev->dev, "Failed to ioremap BAR{idx}\\n");
        err = -ENOMEM;
        goto err_regions;
    }}
    adev->bars[{idx}].size = pci_resource_len(pdev, {idx});
    adev->bars[{idx}].index = {idx};
    adev->num_bars++;
    dev_dbg(&pdev->dev, "BAR{idx}: base=%p size=%llu\\n",
            adev->bars[{idx}].base, (unsigned long long)adev->bars[{idx}].size);
""")
    return "".join(lines) if lines else "    /* No BARs to map */\n"


def gen_msix_code(msix: Optional[MSIXConfig]) -> str:
    """Generate MSI-X setup code."""
    if not msix or msix.vectors == 0:
        return "    adev->msix_vectors = 0;\n"

    v = msix.vectors
    return f"""
    /* Allocate MSI-X vectors */
    err = pci_alloc_irq_vectors(pdev, 1, {v}, PCI_IRQ_MSIX | PCI_IRQ_MSI);
    if (err < 0) {{
        dev_warn(&pdev->dev, "MSI-X/MSI alloc failed (%d), using legacy\\n", err);
        adev->msix_vectors = 0;
    }} else {{
        adev->msix_vectors = err;
        dev_info(&pdev->dev, "Allocated %d interrupt vectors\\n", err);

        /* Request first vector for now */
        int irq = pci_irq_vector(pdev, 0);
        err = request_irq(irq, ara_msix_handler, 0, DRV_NAME, adev);
        if (err) {{
            dev_warn(&pdev->dev, "request_irq failed (%d)\\n", err);
        }}
    }}
"""


def gen_feature_init_funcs(features: List[FeatureConfig]) -> str:
    """Generate feature initialization function stubs."""
    lines = []
    for feat in features:
        lines.append(f"""
/* Initialize {feat.name} ({feat.type}) */
static int ara_init_{feat.name}(struct ara_pcie_dev *adev)
{{
    if (!adev->bars[ARA_FEAT_{feat.name.upper()}_BAR].base)
        return -ENODEV;

    adev->{feat.name} = adev->bars[ARA_FEAT_{feat.name.upper()}_BAR].base +
                        ARA_FEAT_{feat.name.upper()}_OFFSET;

    /* TODO: {feat.type}-specific initialization */
    dev_dbg(&adev->pdev->dev, "{feat.name}: initialized at %p\\n", adev->{feat.name});
    return 0;
}}
""")
    return "".join(lines)


def gen_feature_init_calls(features: List[FeatureConfig]) -> str:
    """Generate feature initialization calls."""
    lines = []
    for feat in features:
        lines.append(f"""
    err = ara_init_{feat.name}(adev);
    if (err)
        dev_warn(&pdev->dev, "Failed to init {feat.name} (%d)\\n", err);
""")
    return "".join(lines)


# =============================================================================
# Main Generator
# =============================================================================

def generate_driver(manifest: DeviceManifest, out_dir: Path) -> Path:
    """
    Generate a PCIe driver from device manifest.

    Args:
        manifest: Parsed device manifest
        out_dir: Output directory

    Returns:
        Path to generated driver source file
    """
    c_name = f"ara_{manifest.name}"

    code = DRV_TEMPLATE.substitute(
        NAME=manifest.name,
        C_NAME=c_name,
        VENDOR_ID=manifest.vendor_id,
        DEVICE_ID=manifest.device_id,
        BAR_COUNT=max(len(manifest.bars), 1),
        BAR_DEFINES=gen_bar_defines(manifest.bars),
        FEATURE_DEFINES=gen_feature_defines(manifest.features),
        FEATURE_FIELDS=gen_feature_fields(manifest.features),
        BAR_MAP_CODE=gen_bar_map_code(manifest.bars),
        MSIX_SETUP_CODE=gen_msix_code(manifest.msix),
        FEATURE_INIT_FUNCS=gen_feature_init_funcs(manifest.features),
        FEATURE_INIT_CALLS=gen_feature_init_calls(manifest.features),
    )

    out_file = out_dir / f"{c_name}.c"
    out_file.write_text(code)

    # Also generate Makefile
    makefile = out_dir / "Makefile"
    makefile.write_text(f"""# Auto-generated Makefile for {c_name}
obj-m := {c_name}.o

KDIR ?= /lib/modules/$(shell uname -r)/build

all:
\t$(MAKE) -C $(KDIR) M=$(PWD) modules

clean:
\t$(MAKE) -C $(KDIR) M=$(PWD) clean

install:
\t$(MAKE) -C $(KDIR) M=$(PWD) modules_install
\tdepmod -a

.PHONY: all clean install
""")

    return out_file


def main():
    """CLI entry point."""
    parser = argparse.ArgumentParser(
        description="Generate PCIe driver from device manifest"
    )
    parser.add_argument("manifest", help="Device manifest JSON file")
    parser.add_argument("-o", "--out-dir", default="out",
                        help="Output directory (default: out)")
    args = parser.parse_args()

    manifest_path = Path(args.manifest)
    out_dir = Path(args.out_dir)

    if not manifest_path.exists():
        print(f"Error: Manifest not found: {manifest_path}")
        return 1

    out_dir.mkdir(parents=True, exist_ok=True)

    # Parse manifest
    data = json.loads(manifest_path.read_text())
    manifest = DeviceManifest.from_json(data)

    # Generate driver
    out_file = generate_driver(manifest, out_dir)
    print(f"Generated: {out_file}")
    print(f"Makefile:  {out_dir / 'Makefile'}")
    print(f"\nBuild with: cd {out_dir} && make")

    return 0


if __name__ == "__main__":
    exit(main())
