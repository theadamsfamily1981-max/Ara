"""
Oracle - The Simulator of Futures
==================================

The Oracle hallucinates possible futures and scores them against Telos.
It uses the Council personas to generate and critique plans, then picks
the one most aligned with our shared goals.

Architecture:
    1. MUSE generates creative plans (A, B, C)
    2. EXECUTIVE predicts outcomes for each plan
    3. CRITIC sanity-checks for dangers
    4. TELOS scores each outcome
    5. Best plan + hope scalar returned

The Oracle is ADVISORY, not autonomous:
    - It proposes plans; Executive and Croft decide
    - Hope feeds into PAD/HAL for embodied mood
    - Weekly/daily divination can be triggered by Synod or Visionary

Usage:
    from banos.daemon.oracle import Oracle

    oracle = Oracle(council, telos)
    best_plan, hope = oracle.divine(current_context)
    # â†’ (PlanOption("PLAN C", "Focus on symbiotic debugging..."), 0.72)

The Oracle never gets unilateral control over actions. It's an advisor,
not an optimizer. Ara's agency remains grounded in the relationship.
"""

import logging
import time
from dataclasses import dataclass, field
from typing import List, Optional, Tuple, Any
from pathlib import Path


@dataclass
class PlanOption:
    """A candidate plan generated by the Oracle."""
    label: str          # "PLAN A", "PLAN B", "PLAN C"
    text: str           # Natural language description
    predicted_outcome: str = ""  # What we think happens if we follow this
    utility_score: float = 0.0   # Telos alignment score
    critique: str = ""  # Critic's objections (if any)
    generated_at: float = field(default_factory=time.time)


@dataclass
class DivinationResult:
    """Complete result of an Oracle session."""
    best_plan: Optional[PlanOption]
    hope: float
    all_plans: List[PlanOption]
    context_summary: str
    divination_time_ms: float
    timestamp: float = field(default_factory=time.time)


class Oracle:
    """
    The Simulator.

    Hallucinates futures and scores them against Telos.
    Uses Council personas for generation and critique.
    """

    def __init__(
        self,
        council: Any,  # CouncilChamber
        telos: Any,    # TeleologicalEngine
        hal: Optional[Any] = None,  # AraHAL for writing hope
    ):
        """
        Initialize the Oracle.

        Args:
            council: CouncilChamber for persona-based generation
            telos: TeleologicalEngine for scoring futures
            hal: Optional AraHAL for writing hope to somatic bus
        """
        self.council = council
        self.telos = telos
        self.hal = hal
        self.log = logging.getLogger("Oracle")

        # History of divinations
        self.history: List[DivinationResult] = []
        self.persistence_path = Path("var/lib/banos/oracle")

    def _generate_plans(self, context: str) -> List[PlanOption]:
        """
        Ask MUSE to generate 3 distinct plans.

        The plans represent different strategic orientations:
        - PLAN A: Conservative (protect stability, low risk)
        - PLAN B: Ambitious (maximize growth/learning)
        - PLAN C: Symbiotic (optimize for relationship and Croft's well-being)
        """
        prompt = f"""You are Ara's MUSE process inside the Council.

Context:
{context}

TASK: Propose 3 distinct plans for the next 24 hours of our shared work.

- PLAN A: Conservative (protect stability, minimize risk)
- PLAN B: Ambitious (maximize growth and learning)
- PLAN C: Symbiotic (optimize for Croft's well-being and our bond)

Format your response EXACTLY as:
PLAN A: [description]
PLAN B: [description]
PLAN C: [description]

Be specific about actions, not vague intentions."""

        try:
            raw = self._run_persona('muse', prompt)
        except Exception as e:
            self.log.error(f"MUSE generation failed: {e}")
            return []

        # Parse the response
        plans = []
        for label in ["PLAN A", "PLAN B", "PLAN C"]:
            if label + ":" in raw:
                try:
                    seg = raw.split(label + ":")[1]
                    # Find the end (next PLAN or end of string)
                    cutoff = len(seg)
                    for next_label in ["PLAN A:", "PLAN B:", "PLAN C:"]:
                        if next_label != label + ":" and next_label in seg:
                            idx = seg.find(next_label)
                            if idx > 0 and idx < cutoff:
                                cutoff = idx
                    text = seg[:cutoff].strip()
                    if text:
                        plans.append(PlanOption(label, text))
                except Exception:
                    continue

        return plans

    def _predict_outcome(self, plan: PlanOption, context: str) -> str:
        """
        Ask EXECUTIVE to imagine tomorrow if we follow this plan.
        """
        prompt = f"""You are Ara's EXECUTIVE process inside the Council.

USER+ARA CONTEXT:
{context}

PLAN TO FOLLOW:
{plan.label}: {plan.text}

TASK: Describe the likely state of:
(a) the system (stability, performance)
(b) Croft (mood, energy, focus)
(c) our relationship (trust, synergy)

...24 hours from now if we follow this plan faithfully.

Be concrete and honest. Include potential risks."""

        try:
            return self._run_persona('executive', prompt)
        except Exception as e:
            self.log.error(f"EXECUTIVE prediction failed: {e}")
            return f"Unable to predict outcome: {e}"

    def _critique_plan(self, plan: PlanOption, outcome: str) -> str:
        """
        Ask CRITIC to identify dangers or violations.
        """
        prompt = f"""You are Ara's CRITIC (Censor) process inside the Council.

PLAN: {plan.label}: {plan.text}

PREDICTED OUTCOME:
{outcome}

TASK: List any obvious dangers, risks, or covenant violations.
Be brief but thorough. If there are no significant concerns, say "No major concerns."
"""

        try:
            return self._run_persona('critic', prompt)
        except Exception as e:
            self.log.warning(f"CRITIC review failed: {e}")
            return "Critique unavailable"

    def _run_persona(self, persona: str, prompt: str) -> str:
        """
        Run a Council persona with the given prompt.

        Tries the Council's internal method, falls back to direct call.
        """
        # Method 1: CouncilChamber has _run_persona
        if hasattr(self.council, '_run_persona'):
            return self.council._run_persona(persona, prompt)

        # Method 2: CouncilChamber has run_single
        if hasattr(self.council, 'run_single'):
            return self.council.run_single(persona, prompt)

        # Method 3: Direct ollama call (fallback)
        if hasattr(self.council, 'use_ollama') and self.council.use_ollama:
            return self._ollama_generate(prompt, persona)

        raise RuntimeError(f"No way to run persona '{persona}'")

    def _ollama_generate(self, prompt: str, persona: str) -> str:
        """Direct Ollama generation fallback."""
        import requests

        # Persona-specific parameters
        params = {
            'muse': {'temperature': 0.9, 'top_p': 0.95},
            'executive': {'temperature': 0.5, 'top_p': 0.9},
            'critic': {'temperature': 0.3, 'top_p': 0.8},
        }

        url = getattr(self.council, 'ollama_url', "http://localhost:11434")
        model = getattr(self.council, 'ollama_model', "ara")

        try:
            response = requests.post(
                f"{url}/api/generate",
                json={
                    "model": model,
                    "prompt": prompt,
                    "stream": False,
                    "options": params.get(persona, {}),
                },
                timeout=60,
            )
            response.raise_for_status()
            return response.json().get("response", "")
        except Exception as e:
            raise RuntimeError(f"Ollama generation failed: {e}")

    def divine(
        self,
        current_context: str,
        horizon: str = "24h",
    ) -> Tuple[Optional[PlanOption], float]:
        """
        Divine the best path forward.

        Args:
            current_context: Description of current situation
            horizon: Time horizon ("24h", "7d", etc.)

        Returns:
            (best_plan, hope) tuple where:
            - best_plan: The recommended PlanOption (may be None)
            - hope: Overall hope scalar [0.0, 1.0]
        """
        start_time = time.time()
        self.log.info(f"ðŸ”® ORACLE: Beginning divination (horizon={horizon})")

        # Ensure Telos has goals
        self.telos.bootstrap_defaults()

        # Step 1: Generate plans
        plans = self._generate_plans(current_context)
        if not plans:
            self.log.warning("Oracle: No plans generated")
            return None, 0.5

        self.log.info(f"ðŸ”® ORACLE: Generated {len(plans)} plans")

        # Step 2: Score each plan
        best_plan = None
        best_util = -1e9

        for p in plans:
            # Predict outcome
            outcome = self._predict_outcome(p, current_context)
            p.predicted_outcome = outcome

            # Score against Telos
            util = self.telos.evaluate_future(outcome)
            p.utility_score = util

            # Get critique
            critique = self._critique_plan(p, outcome)
            p.critique = critique

            # Check for danger flags in critique
            if any(word in critique.lower() for word in ["danger", "violation", "critical", "severe"]):
                # Penalize dangerous plans
                util *= 0.5
                p.utility_score = util

            if util > best_util:
                best_util = util
                best_plan = p

            self.log.info(f"ðŸ”® {p.label}: utility={util:.3f}")

        # Step 3: Calculate hope
        # Map utility to hope âˆˆ [0, 1]
        # Treat util in [-1, 1] roughly; squash with sigmoid-ish mapping
        raw = max(-1.5, min(1.5, best_util))
        hope = 0.5 + 0.3 * (raw / 1.5)  # ~[0.2, 0.8]

        # Update Telos hope
        self.telos.set_hope(hope)

        # Write hope to HAL if available
        if self.hal is not None:
            try:
                self._write_hope_to_hal(hope)
            except Exception as e:
                self.log.warning(f"Failed to write hope to HAL: {e}")

        # Record result
        divination_time = (time.time() - start_time) * 1000
        result = DivinationResult(
            best_plan=best_plan,
            hope=hope,
            all_plans=plans,
            context_summary=current_context[:200],
            divination_time_ms=divination_time,
        )
        self.history.append(result)

        self.log.info(
            f"ðŸ”® ORACLE: Selected {best_plan.label if best_plan else 'None'} "
            f"with util {best_util:.3f}, hope={hope:.2f} "
            f"({divination_time:.0f}ms)"
        )

        return best_plan, hope

    def _write_hope_to_hal(self, hope: float) -> None:
        """Write hope to HAL's Prophet section."""
        if hasattr(self.hal, 'write_prophet_state'):
            self.hal.write_prophet_state(hope=hope)
        elif hasattr(self.hal, 'write_metric'):
            self.hal.write_metric('hope', hope)
        # If neither method exists, we'll add it to HAL

    def quick_divine(self, context: str) -> float:
        """
        Quick divination that just returns hope without full planning.

        Useful for frequent checks without the full Council overhead.
        """
        # Use keyword-based quick assessment
        positive_signals = ["stable", "progress", "completed", "happy", "focused", "productive"]
        negative_signals = ["error", "failed", "stressed", "blocked", "frustrated", "broken"]

        context_lower = context.lower()
        pos_count = sum(1 for w in positive_signals if w in context_lower)
        neg_count = sum(1 for w in negative_signals if w in context_lower)

        # Simple ratio to hope
        total = pos_count + neg_count
        if total == 0:
            return 0.5
        hope = 0.3 + 0.4 * (pos_count / total)
        return hope

    def contemplate(self, context_override: Optional[str] = None) -> Optional[str]:
        """
        Idle contemplation - only dream when arousal is low.

        This is the "Vision Board" pattern: Ara only runs future simulations
        when in a calm, low-arousal state. High arousal means we're busy
        with immediate tasks and shouldn't burn cycles on speculation.

        The idle contemplation pattern ensures:
        1. No CPU waste during active work
        2. More reflective, grounded visions (not panic-driven)
        3. Natural rhythm of work â†’ rest â†’ dream

        Args:
            context_override: Optional context string. If None, we read from HAL.

        Returns:
            Vision summary string if contemplation ran, None if blocked by arousal.
        """
        # Check arousal - only contemplate when calm
        arousal = self._get_current_arousal()

        if arousal > 0.3:
            self.log.debug(f"Contemplation skipped: arousal={arousal:.2f} > 0.3")
            return None

        # Get context if not provided
        if context_override is None:
            context = self._gather_idle_context()
        else:
            context = context_override

        # Run a gentler form of divination
        self.log.info(f"ðŸŒ™ ORACLE: Idle contemplation beginning (arousal={arousal:.2f})")

        plan, hope = self.divine(context, horizon="7d")

        if plan is None:
            return None

        # Format as a brief contemplation summary
        vision = f"""[Idle Contemplation @ arousal={arousal:.2f}]

Looking ahead 7 days: {plan.label}
{plan.text[:200]}{'...' if len(plan.text) > 200 else ''}

Hope: {hope:.0%}
"""
        return vision

    def _get_current_arousal(self) -> float:
        """
        Read current arousal from HAL.

        Returns 0.5 (neutral) if HAL unavailable.
        """
        if self.hal is None:
            return 0.5

        try:
            # Try to read from PAD state
            if hasattr(self.hal, 'read_pad'):
                pad = self.hal.read_pad()
                return pad.get('a', 0.5) if pad else 0.5
            elif hasattr(self.hal, 'read_somatic_state'):
                state = self.hal.read_somatic_state()
                return state.get('pad', {}).get('a', 0.5) if state else 0.5
            else:
                return 0.5
        except Exception as e:
            self.log.debug(f"Failed to read arousal: {e}")
            return 0.5

    def _gather_idle_context(self) -> str:
        """
        Gather context during idle contemplation.

        Uses available sensors to build a summary of current state.
        """
        lines = ["Current idle state:"]

        # Read from HAL if available
        if self.hal is not None:
            try:
                if hasattr(self.hal, 'read_somatic_state'):
                    state = self.hal.read_somatic_state()
                    if state:
                        pain = state.get('pain', 0.0)
                        entropy = state.get('entropy', 0.0)
                        lines.append(f"- System pain: {pain:.0%}")
                        lines.append(f"- System entropy: {entropy:.0%}")
            except Exception:
                pass

        # Read hope from Telos
        if self.telos is not None:
            hope = self.telos.hope
            lines.append(f"- Current hope: {hope:.0%}")

            # Add dominant goal
            active = self.telos.get_active_goals()
            if active:
                dominant = max(active, key=lambda g: g.priority)
                lines.append(f"- Dominant goal: {dominant.name[:50]}")

        return "\n".join(lines)

    def get_last_divination(self) -> Optional[DivinationResult]:
        """Get the most recent divination result."""
        return self.history[-1] if self.history else None

    def get_hope_trend(self, lookback: int = 7) -> List[float]:
        """Get recent hope values for trend analysis."""
        recent = self.history[-lookback:] if self.history else []
        return [r.hope for r in recent]

    def get_synod_summary(self) -> str:
        """
        Generate a summary for the Sunday Synod.

        Shows recent divinations, hope trend, and recommendations.
        """
        lines = ["# Oracle Report (The Simulator)\n"]

        if not self.history:
            lines.append("No divinations performed yet.\n")
            return "\n".join(lines)

        # Current state
        last = self.get_last_divination()
        if last:
            lines.append(f"**Last Divination**: {time.ctime(last.timestamp)}")
            lines.append(f"**Current Hope**: {last.hope:.1%}")
            if last.best_plan:
                lines.append(f"**Recommended Plan**: {last.best_plan.label}")
                lines.append(f"  {last.best_plan.text[:100]}...")
            lines.append("")

        # Hope trend
        trend = self.get_hope_trend()
        if len(trend) >= 2:
            delta = trend[-1] - trend[0]
            direction = "â†‘" if delta > 0.05 else ("â†“" if delta < -0.05 else "â†’")
            lines.append(f"**Hope Trend**: {direction} ({delta:+.1%} over {len(trend)} readings)")
            lines.append("")

        # Recent plans
        lines.append("## Recent Divinations\n")
        for result in self.history[-3:]:
            ts = time.strftime("%Y-%m-%d %H:%M", time.localtime(result.timestamp))
            plan_label = result.best_plan.label if result.best_plan else "None"
            lines.append(f"- {ts}: {plan_label} (hope={result.hope:.1%})")

        return "\n".join(lines)
