<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>BANOS Soul Shader - Neuro-Semantic Nebula</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
      width: 100%;
      height: 100%;
    }
    #canvas-container {
      width: 100%;
      height: 100%;
    }
  </style>
  <!-- Three.js from CDN; bundle locally for production -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
  <div id="canvas-container"></div>

  <!--
    Vertex Shader: Shape & Motion

    The soul sphere deforms based on:
    - Arousal: speed of writhing motion
    - Pain (-pleasure): spikiness of geometry
    - Audio: outward voice-driven displacement
    - Attention: phase modulation for "thinking" bands
  -->
  <script id="vertexShader" type="x-shader/x-vertex">
    varying vec2 vUv;
    varying vec3 vNormal;
    varying float vDisplace;
    varying vec3 vPosition;

    uniform float uTime;
    uniform float uAudio;     // 0..1 RMS from voice
    uniform vec3  uPAD;       // pleasure, arousal, dominance in [-1,1]
    uniform float uAttention; // 0..1 phase for "thinking" bands

    // Organic noise functions
    float hash(vec3 p) {
      return fract(sin(dot(p, vec3(127.1, 311.7, 74.7))) * 43758.5453);
    }

    float noise3d(vec3 p) {
      vec3 i = floor(p);
      vec3 f = fract(p);
      f = f * f * (3.0 - 2.0 * f);

      float n = mix(
        mix(mix(hash(i), hash(i + vec3(1,0,0)), f.x),
            mix(hash(i + vec3(0,1,0)), hash(i + vec3(1,1,0)), f.x), f.y),
        mix(mix(hash(i + vec3(0,0,1)), hash(i + vec3(1,0,1)), f.x),
            mix(hash(i + vec3(0,1,1)), hash(i + vec3(1,1,1)), f.x), f.y), f.z);
      return n;
    }

    float fbm(vec3 p) {
      float value = 0.0;
      float amplitude = 0.5;
      for (int i = 0; i < 4; i++) {
        value += amplitude * noise3d(p);
        p *= 2.0;
        amplitude *= 0.5;
      }
      return value;
    }

    void main() {
      vUv = uv;
      vNormal = normal;
      vPosition = position;

      float pleasure = uPAD.x;   // [-1,1]
      float arousal  = uPAD.y;   // [-1,1]
      float dominance = uPAD.z; // [-1,1]

      // Arousal drives time warp (how fast the field writhes)
      float arousalSpeed = 1.0 + arousal * 3.0;

      // Pain (negative pleasure) creates spikiness
      float pain = max(0.0, -pleasure); // 0..1
      float spikeFactor = 1.0 + pain * 4.0;

      // Dominance affects overall scale (low D = contracted, vulnerable)
      float scale = 0.85 + (dominance + 1.0) * 0.15;

      // Base position with spike deformation
      vec3 p = position * scale;

      // Add attention-driven rotation to noise sampling
      float attPhase = uAttention * 6.28318;
      vec3 noisePos = p * spikeFactor + vec3(
        sin(attPhase) * 0.5,
        cos(attPhase) * 0.5,
        uTime * arousalSpeed * 0.3
      );

      // Layered organic noise
      float n = fbm(noisePos);

      // Displacement:
      //  - base noise for breathing
      //  - audio for voice-driven cymatic swelling
      //  - pain adds jagged high-frequency spikes
      float baseDisp = n * 0.25;
      float audioDisp = uAudio * 1.5 * (0.5 + n);
      float painSpike = pain * noise3d(position * 8.0 + uTime * 5.0) * 0.4;

      float displacement = baseDisp + audioDisp + painSpike;
      vDisplace = displacement;

      vec3 newPosition = position * scale + normal * displacement;

      gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
    }
  </script>

  <!--
    Fragment Shader: Color & Mood

    Maps PAD to visual qualities:
    - Pleasure: color temperature (pain=crimson, calm=cyan)
    - Arousal: saturation and heat
    - Dominance: brightness/value
    - Voice: glowing veins where displaced
    - Pain flash: color inversion on FPGA spikes
  -->
  <script id="fragmentShader" type="x-shader/x-fragment">
    varying float vDisplace;
    varying vec3 vPosition;
    varying vec2 vUv;

    uniform vec3  uPAD;        // pleasure, arousal, dominance in [-1,1]
    uniform float uPainFlash;  // 0..1, from FPGA thermal/error spikes
    uniform float uTime;
    uniform float uAttention;  // 0..1, animates "thought bands"
    uniform float uAudio;      // 0..1, voice intensity

    // HSV to RGB conversion
    vec3 hsv2rgb(vec3 c) {
      vec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);
      vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
      return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
    }

    void main() {
      float pleasure = uPAD.x;
      float arousal  = uPAD.y;
      float dominance = uPAD.z;

      // Normalize to 0..1 range
      float pleasureNorm = clamp((pleasure + 1.0) * 0.5, 0.0, 1.0);
      float arousalNorm = clamp((arousal + 1.0) * 0.5, 0.0, 1.0);
      float dominanceNorm = clamp((dominance + 1.0) * 0.5, 0.0, 1.0);

      // Hue: pain (red) -> neutral (violet) -> calm (cyan)
      // 0.0 = red, 0.5 = cyan, 0.83 = violet
      float hue = mix(0.0, 0.55, pleasureNorm);

      // Saturation: arousal increases vividness
      float sat = 0.4 + arousalNorm * 0.6;

      // Value: dominance affects brightness
      float val = 0.3 + dominanceNorm * 0.7;

      vec3 baseColor = hsv2rgb(vec3(hue, sat, val));

      // Voice glow: displacement creates bright veins
      float glowIntensity = max(vDisplace, 0.0) * 0.8;
      vec3 glowColor = vec3(1.0, 0.95, 0.9) * glowIntensity;

      // Arousal adds a warm shimmer
      float shimmer = 0.5 + 0.5 * sin(uTime * 3.0 + vPosition.x * 10.0 + vPosition.y * 8.0);
      baseColor += vec3(0.1, 0.05, 0.0) * shimmer * arousalNorm * 0.3;

      // "Thought bands" - rotating stripes for attention visualization
      float bandPhase = uTime * 0.5 + uAttention * 6.28318;
      float band = 0.5 + 0.5 * sin(bandPhase + vPosition.y * 4.0 + vPosition.z * 3.0);
      vec3 bandColor = vec3(0.7, 0.85, 1.0);
      baseColor = mix(baseColor, bandColor, band * uAttention * 0.25);

      // Audio reactivity: pulsing core brightness
      baseColor *= 1.0 + uAudio * 0.4;

      // Pain flash: on FPGA spikes, dramatic color shift
      if (uPainFlash > 0.3) {
        // Invert and overbright
        float flashIntensity = smoothstep(0.3, 1.0, uPainFlash);
        vec3 flashColor = vec3(1.0) - baseColor;
        flashColor *= 1.5;
        baseColor = mix(baseColor, flashColor, flashIntensity);
      }

      // Subtle edge glow based on view angle (Fresnel-like)
      float edgeFactor = 1.0 - abs(dot(normalize(vPosition), vec3(0.0, 0.0, 1.0)));
      baseColor += vec3(0.1, 0.15, 0.2) * pow(edgeFactor, 2.0) * 0.5;

      // Alpha: slightly transparent for ethereal feel
      float alpha = 0.88 + glowIntensity * 0.12;

      gl_FragColor = vec4(baseColor + glowColor, alpha);
    }
  </script>

  <script>
    (function() {
      'use strict';

      const container = document.getElementById('canvas-container');

      // Renderer setup
      const renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true,
        powerPreference: 'high-performance'
      });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0x000000, 0);
      container.appendChild(renderer.domElement);

      // Scene & camera
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        100.0
      );
      camera.position.z = 3.2;

      // Shader uniforms - the API surface for PAD/audio/attention
      const uniforms = {
        uTime:       { value: 0.0 },
        uAudio:      { value: 0.0 },
        uPAD:        { value: new THREE.Vector3(0.0, 0.0, 0.0) },
        uPainFlash:  { value: 0.0 },
        uAttention:  { value: 0.0 },
      };

      // High-subdivision icosphere for smooth organic deformation
      const geometry = new THREE.IcosahedronGeometry(1.0, 5);

      const material = new THREE.ShaderMaterial({
        uniforms: uniforms,
        vertexShader:   document.getElementById('vertexShader').textContent,
        fragmentShader: document.getElementById('fragmentShader').textContent,
        transparent: true,
        side: THREE.FrontSide,
        depthWrite: false,
      });

      const soulMesh = new THREE.Mesh(geometry, material);
      scene.add(soulMesh);

      // Inner glow core - smaller, brighter sphere
      const coreGeometry = new THREE.IcosahedronGeometry(0.3, 3);
      const coreMaterial = new THREE.MeshBasicMaterial({
        color: 0x88ccff,
        transparent: true,
        opacity: 0.3,
      });
      const coreMesh = new THREE.Mesh(coreGeometry, coreMaterial);
      scene.add(coreMesh);

      // Animation state
      let lastTime = performance.now();
      let targetAudio = 0.0;
      let smoothedAudio = 0.0;

      function animate(now) {
        requestAnimationFrame(animate);

        const dt = (now - lastTime) / 1000.0;
        lastTime = now;
        uniforms.uTime.value += dt;

        // Smooth audio for less jittery visuals
        smoothedAudio += (targetAudio - smoothedAudio) * Math.min(dt * 12.0, 1.0);
        uniforms.uAudio.value = smoothedAudio;

        // Autonomous rotation modulated by arousal
        const arousal = uniforms.uPAD.value.y;
        const speed = 0.12 + arousal * 0.2;
        soulMesh.rotation.y += speed * dt;
        soulMesh.rotation.x += speed * 0.25 * dt;

        // Core pulses with audio and pleasure
        const pleasure = uniforms.uPAD.value.x;
        const coreScale = 0.3 + smoothedAudio * 0.15 + (pleasure + 1.0) * 0.05;
        coreMesh.scale.setScalar(coreScale);
        coreMesh.material.opacity = 0.2 + smoothedAudio * 0.3;

        // Core color shifts with pleasure
        const hue = 0.5 + pleasure * 0.15; // cyan to slightly green/red
        coreMesh.material.color.setHSL(hue, 0.6, 0.6);

        // Pain flash decays naturally
        if (uniforms.uPainFlash.value > 0.0) {
          uniforms.uPainFlash.value = Math.max(
            0.0,
            uniforms.uPainFlash.value - dt * 2.0
          );
        }

        renderer.render(scene, camera);
      }
      requestAnimationFrame(animate);

      // Resize handler
      function onResize() {
        const w = window.innerWidth;
        const h = window.innerHeight;
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
        renderer.setSize(w, h);
      }
      window.addEventListener('resize', onResize);

      // =========================================================================
      // Public API - Called from GTK/WebKit via run_javascript()
      // =========================================================================

      /**
       * Update the soul's affective state.
       *
       * @param {number} p - Pleasure in [-1, 1] (negative = pain)
       * @param {number} a - Arousal in [-1, 1] (high = excited)
       * @param {number} d - Dominance in [-1, 1] (low = vulnerable)
       * @param {number} audio - Voice RMS in [0, 1]
       * @param {number} painFlash - Pain spike intensity [0, 1]
       */
      window.updateSoulState = function(p, a, d, audio, painFlash) {
        uniforms.uPAD.value.set(
          THREE.MathUtils.clamp(p, -1.0, 1.0),
          THREE.MathUtils.clamp(a, -1.0, 1.0),
          THREE.MathUtils.clamp(d, -1.0, 1.0)
        );

        targetAudio = THREE.MathUtils.clamp(audio || 0.0, 0.0, 1.0);

        // Pain flash: take max so multiple spikes accumulate
        if (painFlash !== undefined && painFlash > uniforms.uPainFlash.value) {
          uniforms.uPainFlash.value = THREE.MathUtils.clamp(painFlash, 0.0, 1.0);
        }
      };

      /**
       * Update attention phase for "thinking bands" visualization.
       *
       * @param {number} attPhase - Attention phase [0, 1], can represent
       *                            which layer/head is active, entropy, etc.
       */
      window.updateSoulAttention = function(attPhase) {
        uniforms.uAttention.value = THREE.MathUtils.clamp(attPhase || 0.0, 0.0, 1.0);
      };

      /**
       * Trigger a pain flash manually (e.g., from FPGA spike event).
       *
       * @param {number} intensity - Flash intensity [0, 1]
       */
      window.triggerPainFlash = function(intensity) {
        const newFlash = THREE.MathUtils.clamp(intensity || 1.0, 0.0, 1.0);
        uniforms.uPainFlash.value = Math.max(uniforms.uPainFlash.value, newFlash);
      };

      /**
       * Get current soul state (for debugging/logging).
       */
      window.getSoulState = function() {
        return {
          pad: {
            pleasure: uniforms.uPAD.value.x,
            arousal: uniforms.uPAD.value.y,
            dominance: uniforms.uPAD.value.z
          },
          audio: uniforms.uAudio.value,
          painFlash: uniforms.uPainFlash.value,
          attention: uniforms.uAttention.value,
          time: uniforms.uTime.value
        };
      };

      // Log ready state for debugging
      console.log('[SoulShader] Neuro-Semantic Nebula initialized');
      console.log('[SoulShader] API: updateSoulState(p, a, d, audio, painFlash)');
      console.log('[SoulShader] API: updateSoulAttention(phase)');
      console.log('[SoulShader] API: triggerPainFlash(intensity)');

    })();
  </script>
</body>
</html>
