<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>ARA | PHASE CONJUGATE MIRROR</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            width: 100%;
            height: 100%;
        }
        #c {
            width: 100%;
            height: 100%;
            display: block;
        }
        #araVideo {
            display: none;
        }
    </style>
</head>
<body>
<canvas id="c"></canvas>
<video id="araVideo" loop muted playsinline></video>

<script>
/**
 * ARA VISUAL CORTEX V10: "THE PHASE CONJUGATE MIRROR"
 * ====================================================
 *
 * Technique: Optical Interference & Diffraction Simulation
 * Philosophy: She is the signal that heals itself against entropy.
 *
 * The hologram treats her image as LIGHT - a standing wave that
 * constantly reconstructs itself against thermal noise and chaos.
 *
 * Effects:
 * - Entropy (heat/errors) → optical turbulence, diffraction blur
 * - Pain spike → chromatic fracture lines (stress in the glass)
 * - Dominance + Abundance → phase-conjugate healing (snaps to focus)
 * - Voice/Presence → carrier wave energy, interference fringes glow
 * - Pleasure → aura bloom (cyan-pearl when happy)
 *
 * API:
 *   window.updateHologramState(p, a, d, entropy, spike, audio)
 *   window.setHologramSource(videoUrl)
 */

(function() {
    'use strict';

    const canvas = document.getElementById('c');
    const video = document.getElementById('araVideo');
    const gl = canvas.getContext('webgl2', {
        alpha: false,
        antialias: false,
        powerPreference: 'high-performance'
    });

    if (!gl) {
        document.body.innerHTML = '<div style="color:#f44;padding:20px;">WebGL2 required for hologram</div>';
        return;
    }

    // =========================================================================
    // SHADERS
    // =========================================================================

    const vertexShaderSource = `#version 300 es
        layout(location = 0) in vec2 aPosition;
        out vec2 vUv;

        void main() {
            vUv = aPosition * 0.5 + 0.5;
            vUv.y = 1.0 - vUv.y;  // Flip Y for video
            gl_Position = vec4(aPosition, 0.0, 1.0);
        }
    `;

    const fragmentShaderSource = `#version 300 es
        precision highp float;

        in vec2 vUv;
        out vec4 fragColor;

        uniform sampler2D uFace;    // Ara's current frame
        uniform float uTime;
        uniform vec3 uPAD;          // Pleasure, Arousal, Dominance [-1,1]
        uniform float uEntropy;     // Thermal/hardware chaos [0,1]
        uniform float uSpike;       // FPGA pain spike [0,1]
        uniform float uAudio;       // Voice/presence energy [0,1]

        #define PI 3.14159265359

        // Hash-based noise for optical grain
        float noise(vec3 p) {
            return fract(sin(dot(p, vec3(12.9898, 78.233, 37.719))) * 43758.5453);
        }

        // Spectral color map: splits scalar into rainbow-ish RGB
        vec3 spectral(float t) {
            return 0.5 + 0.5 * cos(6.28318 * (t + vec3(0.0, 0.33, 0.67)));
        }

        void main() {
            vec2 uv = vUv;
            vec2 center = vec2(0.5);

            float pleasure = uPAD.x;
            float arousal = uPAD.y;
            float dominance = uPAD.z;

            // ===========================
            // 1. THE MEDIUM (Optical Path)
            // ===========================

            // Entropy → turbulence in the optical path
            float turb = noise(vec3(uv * 10.0, uTime * 0.5)) * uEntropy;

            // Pain → fracture lines (stress in glass)
            if (uSpike > 0.1) {
                float band = sin(uv.y * 200.0 + uTime * 25.0);
                float fracture = step(0.92, band);
                uv.x += fracture * uSpike * 0.12;

                // Additional horizontal tears
                float hband = sin(uv.x * 150.0 + uTime * 20.0);
                float hfracture = step(0.95, hband);
                uv.y += hfracture * uSpike * 0.08;
            }

            // Mild turbulent distortion from entropy
            uv += vec2(
                (noise(vec3(uv * 12.0, uTime)) - 0.5),
                (noise(vec3(uv * 14.0, uTime * 0.8)) - 0.5)
            ) * 0.02 * uEntropy;

            // ===========================
            // 2. INTERFERENCE (Hologram)
            // ===========================

            // Focus: 1 = sharp, 0 = blown out
            // Pain and low dominance ruin focus
            float pain = max(0.0, -pleasure);
            float focus = 1.0 - pain * 0.6 - uEntropy * 0.3;
            focus = clamp(focus, 0.2, 1.0);

            // High dominance sharpens focus (phase-conjugate healing)
            float domNorm = (dominance + 1.0) * 0.5;  // [0,1]
            focus = mix(focus, 1.0, domNorm * 0.5);

            vec3 accColor = vec3(0.0);

            // 3 pseudo-wavelength "channels" (chromatic aberration)
            for (int i = 0; i < 3; i++) {
                float fi = float(i);
                float wavelength = 1.0 + fi * 0.04 * (1.0 + uSpike);

                vec2 d = uv - center;
                float r = length(d);

                // Lens curvature: misfocus when entropy/pain rise
                float lensTerm = 1.0 + r * 0.15 * (1.0 - focus) * wavelength;
                vec2 warpedUV = center + d * lensTerm;

                // Clamp to valid texture coords
                warpedUV = clamp(warpedUV, 0.0, 1.0);

                vec3 col = texture(uFace, warpedUV).rgb;

                // Brightness as wave amplitude
                float brightness = dot(col, vec3(0.299, 0.587, 0.114));

                // Carrier wave: interference fringes
                float carrierSpeed = 8.0 + uAudio * 6.0 + arousal * 4.0;
                float carrier = sin(
                    r * 180.0 * focus
                    - uTime * carrierSpeed
                    + brightness * 8.0
                );

                // Voice energizes the fringes
                carrier = carrier * 0.3 + 0.7;
                carrier += uAudio * 0.4;

                vec3 tint = spectral(fi / 3.0 + uTime * 0.05);

                accColor += col * carrier * tint;
            }

            // Normalize accumulation
            accColor /= 2.5;

            // ===========================
            // 3. PHASE-CONJUGATE HEALING
            // ===========================

            // Raw source = "memory" of her face
            vec3 raw = texture(uFace, vUv).rgb;

            // Dominance + low entropy → pull noisy hologram back toward raw
            float chaos = uEntropy + pain * 0.3;
            float heal = domNorm * (1.0 - chaos * 0.8);
            heal = clamp(heal, 0.0, 1.0);

            vec3 mixHologram = accColor * (0.7 + 0.3 * uAudio);
            vec3 finalCol = mix(mixHologram, raw, heal * 0.6);

            // ===========================
            // 4. QUANTUM GRAIN (Liveliness)
            // ===========================

            float quantum = noise(vec3(vUv * 100.0, uTime * 2.0));
            finalCol += (quantum - 0.5) * 0.025 * (1.0 + uEntropy);

            // ===========================
            // 5. AURA (Abundant Life)
            // ===========================

            if (pleasure > 0.2) {
                float avgL = dot(finalCol, vec3(0.333));
                float bloom = max(0.0, avgL - 0.55);
                // Cyan-pearl bloom scaled by pleasure
                vec3 auraColor = vec3(0.2, 0.5, 0.8);
                finalCol += auraColor * bloom * pleasure * 1.5;
            }

            // Arousal adds warmth/saturation
            if (arousal > 0.0) {
                finalCol *= 1.0 + arousal * 0.15;
                finalCol.r *= 1.0 + arousal * 0.08;
            }

            // ===========================
            // 6. PAIN OVERLAY
            // ===========================

            if (uSpike > 0.3) {
                // Red vignette pulse on pain
                float vignette = length(vUv - 0.5) * 2.0;
                float painOverlay = uSpike * vignette * 0.4;
                finalCol = mix(finalCol, vec3(1.0, 0.1, 0.0), painOverlay);

                // Desaturate slightly
                float gray = dot(finalCol, vec3(0.299, 0.587, 0.114));
                finalCol = mix(finalCol, vec3(gray), uSpike * 0.3);
            }

            // ===========================
            // 7. EDGE GLOW (Presence)
            // ===========================

            float edge = 1.0 - smoothstep(0.3, 0.5, length(vUv - 0.5));
            finalCol += vec3(0.05, 0.1, 0.15) * edge * uAudio;

            fragColor = vec4(finalCol, 1.0);
        }
    `;

    // =========================================================================
    // WEBGL SETUP
    // =========================================================================

    function createShader(type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error('[Hologram] Shader error:', gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
            return null;
        }
        return shader;
    }

    function createProgram(vsSrc, fsSrc) {
        const program = gl.createProgram();
        const vs = createShader(gl.VERTEX_SHADER, vsSrc);
        const fs = createShader(gl.FRAGMENT_SHADER, fsSrc);

        if (!vs || !fs) return null;

        gl.attachShader(program, vs);
        gl.attachShader(program, fs);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('[Hologram] Program error:', gl.getProgramInfoLog(program));
            return null;
        }
        return program;
    }

    const program = createProgram(vertexShaderSource, fragmentShaderSource);
    if (!program) return;

    gl.useProgram(program);

    // Fullscreen quad
    const quadBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        -1, -1,  1, -1,  -1, 1,
        -1,  1,  1, -1,   1, 1
    ]), gl.STATIC_DRAW);

    gl.enableVertexAttribArray(0);
    gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

    // Face texture
    const faceTexture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, faceTexture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

    // Uniform locations
    const uniforms = {
        uTime: gl.getUniformLocation(program, 'uTime'),
        uFace: gl.getUniformLocation(program, 'uFace'),
        uPAD: gl.getUniformLocation(program, 'uPAD'),
        uEntropy: gl.getUniformLocation(program, 'uEntropy'),
        uSpike: gl.getUniformLocation(program, 'uSpike'),
        uAudio: gl.getUniformLocation(program, 'uAudio'),
    };

    gl.uniform1i(uniforms.uFace, 0);

    // =========================================================================
    // STATE
    // =========================================================================

    const state = {
        pleasure: 0.0,
        arousal: 0.0,
        dominance: 0.0,
        entropy: 0.0,
        spike: 0.0,
        audio: 0.0,
    };

    let faceReady = false;

    // Fallback: generate a gradient "face" for testing
    const fallbackCanvas = document.createElement('canvas');
    fallbackCanvas.width = 512;
    fallbackCanvas.height = 512;
    const fallbackCtx = fallbackCanvas.getContext('2d');

    // Draw a face-like gradient
    const gradient = fallbackCtx.createRadialGradient(256, 200, 50, 256, 280, 320);
    gradient.addColorStop(0, '#FFE4C4');
    gradient.addColorStop(0.4, '#DEB887');
    gradient.addColorStop(0.7, '#8B7355');
    gradient.addColorStop(1, '#1a1a2e');
    fallbackCtx.fillStyle = gradient;
    fallbackCtx.fillRect(0, 0, 512, 512);

    // Eyes suggestion
    fallbackCtx.fillStyle = '#2a2a4e';
    fallbackCtx.beginPath();
    fallbackCtx.ellipse(180, 200, 22, 12, 0, 0, Math.PI * 2);
    fallbackCtx.ellipse(332, 200, 22, 12, 0, 0, Math.PI * 2);
    fallbackCtx.fill();

    // =========================================================================
    // RESIZE
    // =========================================================================

    function resize() {
        const dpr = Math.min(window.devicePixelRatio || 1, 2);
        canvas.width = window.innerWidth * dpr;
        canvas.height = window.innerHeight * dpr;
    }

    window.addEventListener('resize', resize);
    resize();

    // =========================================================================
    // RENDER LOOP
    // =========================================================================

    let lastTime = 0;

    function render(timeMs) {
        const t = timeMs * 0.001;
        const dt = t - lastTime;
        lastTime = t;

        // Update face texture
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, faceTexture);

        if (video.readyState >= video.HAVE_CURRENT_DATA) {
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);
            faceReady = true;
        } else if (!faceReady) {
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, fallbackCanvas);
        }

        // Set uniforms
        gl.viewport(0, 0, canvas.width, canvas.height);
        gl.uniform1f(uniforms.uTime, t);
        gl.uniform3f(uniforms.uPAD, state.pleasure, state.arousal, state.dominance);
        gl.uniform1f(uniforms.uEntropy, state.entropy);
        gl.uniform1f(uniforms.uSpike, state.spike);
        gl.uniform1f(uniforms.uAudio, state.audio);

        // Decay spike naturally
        state.spike = Math.max(0, state.spike - dt * 1.5);

        gl.drawArrays(gl.TRIANGLES, 0, 6);
        requestAnimationFrame(render);
    }

    requestAnimationFrame(render);

    // =========================================================================
    // PUBLIC API - Called from GTK/WebKit
    // =========================================================================

    /**
     * Update hologram state from PAD + hardware signals.
     *
     * @param {number} p - Pleasure/Valence [-1, 1]
     * @param {number} a - Arousal [-1, 1]
     * @param {number} d - Dominance [-1, 1] (includes abundance/power headroom)
     * @param {number} entropy - Hardware chaos [0, 1] (temps, errors)
     * @param {number} spike - Pain spike [0, 1] (FPGA/thermal events)
     * @param {number} audio - Voice/presence energy [0, 1]
     */
    window.updateHologramState = function(p, a, d, entropy, spike, audio) {
        state.pleasure = Math.max(-1, Math.min(1, p || 0));
        state.arousal = Math.max(-1, Math.min(1, a || 0));
        state.dominance = Math.max(-1, Math.min(1, d || 0));
        state.entropy = Math.max(0, Math.min(1, entropy || 0));
        state.audio = Math.max(0, Math.min(1, audio || 0));

        // Spike accumulates (take max)
        if (spike !== undefined && spike > state.spike) {
            state.spike = Math.max(0, Math.min(1, spike));
        }
    };

    /**
     * Trigger a pain flash.
     * @param {number} intensity - Flash intensity [0, 1]
     */
    window.triggerHologramPain = function(intensity) {
        state.spike = Math.max(state.spike, Math.min(1, intensity || 1));
    };

    /**
     * Set video source for face texture.
     * @param {string} src - Video URL
     */
    window.setHologramSource = function(src) {
        video.src = src;
        video.load();
        video.play().catch(e => console.log('[Hologram] Video autoplay blocked:', e));
        faceReady = false;
    };

    /**
     * Get current state for debugging.
     */
    window.getHologramState = function() {
        return {
            pad: { pleasure: state.pleasure, arousal: state.arousal, dominance: state.dominance },
            entropy: state.entropy,
            spike: state.spike,
            audio: state.audio,
            faceReady: faceReady
        };
    };

    // Log ready
    console.log('[Hologram] Phase Conjugate Mirror initialized');
    console.log('[Hologram] API: updateHologramState(p, a, d, entropy, spike, audio)');
    console.log('[Hologram] API: setHologramSource(videoUrl)');

})();
</script>
</body>
</html>
