#!/usr/bin/env python3
"""
AI Tile Register Code Generator

Generates RTL, C headers, and documentation from YAML register specification.

Usage:
    python gen_code.py [--output-dir OUTPUT_DIR]

Generates:
    - hw/rtl/ai_csr.v               Verilog register block
    - sw/libaictile/include/ai_tile_regs.h   C header
    - docs/REGISTER_MAP.md          Documentation

Author: A10PED Neuromorphic Project
License: BSD-3-Clause
"""

import yaml
import argparse
from pathlib import Path
from typing import Dict, List, Any
from datetime import datetime


class RegisterCodeGenerator:
    """Generate code from register specification YAML"""

    def __init__(self, spec_path: Path):
        """Load and parse YAML specification"""
        with open(spec_path, 'r') as f:
            self.spec = yaml.safe_load(f)

        self.metadata = self.spec['metadata']
        self.registers = self.spec['registers']
        self.address_space = self.spec['address_space']
        self.command_sequences = self.spec.get('command_sequences', [])
        self.validation = self.spec.get('validation', [])

    def generate_all(self, output_base: Path):
        """Generate all output files"""
        print(f"Generating code from {self.metadata['description']}")
        print(f"Version: {self.metadata['version']}")

        # Create output directories
        rtl_dir = output_base / 'hw' / 'rtl'
        c_dir = output_base / 'sw' / 'libaictile' / 'include'
        doc_dir = output_base / 'docs'

        rtl_dir.mkdir(parents=True, exist_ok=True)
        c_dir.mkdir(parents=True, exist_ok=True)
        doc_dir.mkdir(parents=True, exist_ok=True)

        # Generate files
        print("\nGenerating Verilog RTL...")
        rtl_path = rtl_dir / 'ai_csr.v'
        with open(rtl_path, 'w') as f:
            f.write(self.generate_verilog())
        print(f"  → {rtl_path}")

        print("Generating C header...")
        c_path = c_dir / 'ai_tile_regs.h'
        with open(c_path, 'w') as f:
            f.write(self.generate_c_header())
        print(f"  → {c_path}")

        print("Generating documentation...")
        doc_path = doc_dir / 'REGISTER_MAP.md'
        with open(doc_path, 'w') as f:
            f.write(self.generate_markdown())
        print(f"  → {doc_path}")

        print("\n✅ Code generation complete!")

    def generate_verilog(self) -> str:
        """Generate Verilog register block"""
        lines = []

        # Header
        lines.append("//")
        lines.append("// AI Tile Control/Status Registers (auto-generated)")
        lines.append("//")
        lines.append(f"// Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        lines.append(f"// Source: ai_tile_registers.yaml v{self.metadata['version']}")
        lines.append(f"// License: {self.metadata['license']}")
        lines.append("//")
        lines.append("// DO NOT EDIT THIS FILE MANUALLY!")
        lines.append("// All changes must be made to the YAML specification.")
        lines.append("//")
        lines.append("")

        # Module declaration
        lines.append("module ai_csr (")
        lines.append("    // Clock and reset")
        lines.append("    input  wire        clk,")
        lines.append("    input  wire        rst_n,")
        lines.append("")
        lines.append("    // Avalon-MM slave interface")
        lines.append("    input  wire [11:0] avs_address,")
        lines.append("    input  wire        avs_write,")
        lines.append("    input  wire        avs_read,")
        lines.append("    input  wire [31:0] avs_writedata,")
        lines.append("    output reg  [31:0] avs_readdata,")
        lines.append("    output wire        avs_waitrequest,")
        lines.append("")
        lines.append("    // Status inputs from AI core")
        lines.append("    input  wire        core_busy,")
        lines.append("    input  wire        core_done,")
        lines.append("    input  wire        core_error,")
        lines.append("    input  wire        ddr_ready,")
        lines.append("    input  wire [7:0]  error_code_in,")
        lines.append("    input  wire [31:0] perf_cycles_in,")
        lines.append("    input  wire [31:0] ddr_bandwidth_in,")
        lines.append("    input  wire [15:0] temperature_in,")
        lines.append("")
        lines.append("    // Control outputs to AI core")
        lines.append("    output reg         cmd_start,")
        lines.append("    output reg         cmd_reset,")
        lines.append("    output reg         cmd_abort,")
        lines.append("    output reg  [63:0] cmd_src_addr,")
        lines.append("    output reg  [63:0] cmd_dst_addr,")
        lines.append("    output reg  [31:0] cmd_length,")
        lines.append("    output reg  [31:0] cmd_config,")
        lines.append("    output reg  [31:0] snn_threshold,")
        lines.append("    output reg  [31:0] snn_leak,")
        lines.append("    output reg  [15:0] snn_refract")
        lines.append(");")
        lines.append("")

        # No wait states
        lines.append("    assign avs_waitrequest = 1'b0;")
        lines.append("")

        # Register declarations
        lines.append("    // Register storage")
        for reg in self.registers:
            if reg['access'] in ['RW', 'RO']:
                lines.append(f"    reg [31:0] {reg['name'].lower()}_reg;")
        lines.append("")

        # Write logic
        lines.append("    // Write logic")
        lines.append("    always @(posedge clk or negedge rst_n) begin")
        lines.append("        if (!rst_n) begin")
        lines.append("            // Reset all writable registers")
        for reg in self.registers:
            if reg['access'] == 'RW':
                lines.append(f"            {reg['name'].lower()}_reg <= 32'h{reg['reset_value']:08X};")
        lines.append("        end else begin")
        lines.append("            // Self-clearing bits")
        lines.append("            cmd_start <= 1'b0;")
        lines.append("            cmd_reset <= 1'b0;")
        lines.append("            cmd_abort <= 1'b0;")
        lines.append("")
        lines.append("            if (avs_write) begin")
        lines.append("                case (avs_address[11:2])  // Word-aligned")

        for reg in self.registers:
            if reg['access'] == 'RW':
                offset_word = reg['offset'] >> 2
                lines.append(f"                    10'd{offset_word}: {reg['name'].lower()}_reg <= avs_writedata;")

        lines.append("                    default: ;")
        lines.append("                endcase")
        lines.append("            end")
        lines.append("        end")
        lines.append("    end")
        lines.append("")

        # Read logic
        lines.append("    // Read logic")
        lines.append("    always @(posedge clk or negedge rst_n) begin")
        lines.append("        if (!rst_n) begin")
        lines.append("            avs_readdata <= 32'h0;")
        lines.append("        end else if (avs_read) begin")
        lines.append("            case (avs_address[11:2])")

        for reg in self.registers:
            offset_word = reg['offset'] >> 2
            if reg['name'] == 'STATUS':
                # Build status register from inputs
                lines.append(f"                10'd{offset_word}: avs_readdata <= {{")
                lines.append("                    26'b0,")
                lines.append("                    1'b0,          // THERMAL_WARNING")
                lines.append("                    ddr_ready,     // DDR_READY")
                lines.append("                    1'b0,          // IRQ_PENDING")
                lines.append("                    core_error,    // ERROR")
                lines.append("                    core_done,     // DONE")
                lines.append("                    core_busy      // BUSY")
                lines.append("                };")
            elif reg['name'] == 'VERSION':
                lines.append(f"                10'd{offset_word}: avs_readdata <= 32'h{reg['reset_value']:08X};  // Version")
            elif reg['name'] == 'CAPABILITIES':
                lines.append(f"                10'd{offset_word}: avs_readdata <= 32'h{reg['reset_value']:08X};  // Capabilities")
            elif reg['name'] == 'ERROR_CODE':
                lines.append(f"                10'd{offset_word}: avs_readdata <= {{24'b0, error_code_in}};")
            elif reg['name'] == 'PERF_CYCLES':
                lines.append(f"                10'd{offset_word}: avs_readdata <= perf_cycles_in;")
            elif reg['name'] == 'DDR_BANDWIDTH':
                lines.append(f"                10'd{offset_word}: avs_readdata <= ddr_bandwidth_in;")
            elif reg['name'] == 'TEMPERATURE':
                lines.append(f"                10'd{offset_word}: avs_readdata <= {{16'b0, temperature_in}};")
            else:
                lines.append(f"                10'd{offset_word}: avs_readdata <= {reg['name'].lower()}_reg;")

        lines.append("                default: avs_readdata <= 32'hDEADBEEF;")
        lines.append("            endcase")
        lines.append("        end")
        lines.append("    end")
        lines.append("")

        # Output assignments
        lines.append("    // Output assignments")
        lines.append("    always @(*) begin")
        lines.append("        cmd_start = avs_write && (avs_address[11:2] == 10'd0) && avs_writedata[0];")
        lines.append("        cmd_reset = avs_write && (avs_address[11:2] == 10'd0) && avs_writedata[1];")
        lines.append("        cmd_abort = avs_write && (avs_address[11:2] == 10'd0) && avs_writedata[3];")
        lines.append("        cmd_src_addr = {cmd_src_hi_reg, cmd_src_lo_reg};")
        lines.append("        cmd_dst_addr = {cmd_dst_hi_reg, cmd_dst_lo_reg};")
        lines.append("        cmd_length = cmd_len_reg;")
        lines.append("        cmd_config = cmd_cfg_reg;")
        lines.append("        snn_threshold = snn_threshold_reg;")
        lines.append("        snn_leak = snn_leak_reg;")
        lines.append("        snn_refract = snn_refract_reg[15:0];")
        lines.append("    end")
        lines.append("")
        lines.append("endmodule")
        lines.append("")

        return '\n'.join(lines)

    def generate_c_header(self) -> str:
        """Generate C header file"""
        lines = []

        # Header guard
        guard = "AI_TILE_REGS_H"
        lines.append(f"#ifndef {guard}")
        lines.append(f"#define {guard}")
        lines.append("")
        lines.append("/*")
        lines.append(" * AI Tile Register Definitions (auto-generated)")
        lines.append(" *")
        lines.append(f" * Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        lines.append(f" * Source: ai_tile_registers.yaml v{self.metadata['version']}")
        lines.append(f" * License: {self.metadata['license']}")
        lines.append(" *")
        lines.append(" * DO NOT EDIT THIS FILE MANUALLY!")
        lines.append(" * All changes must be made to the YAML specification.")
        lines.append(" */")
        lines.append("")
        lines.append("#include <stdint.h>")
        lines.append("")

        # Register offsets
        lines.append("/* Register Offsets */")
        for reg in self.registers:
            name_upper = reg['name'].upper()
            lines.append(f"#define AI_TILE_{name_upper}_OFFSET    0x{reg['offset']:04X}")
        lines.append("")

        # Field definitions
        lines.append("/* Register Field Definitions */")
        for reg in self.registers:
            lines.append(f"\n/* {reg['name']} - {reg['description']} */")
            for field in reg['fields']:
                field_name = f"AI_TILE_{reg['name'].upper()}_{field['name'].upper()}"

                # Calculate mask and shift
                bits = field['bits']
                if isinstance(bits, list):
                    if len(bits) == 1:
                        # Single bit
                        bit_pos = bits[0]
                        mask = 1 << bit_pos
                        shift = bit_pos
                    else:
                        # Range [high:low]
                        high = bits[0]
                        low = bits[1]
                        width = high - low + 1
                        mask = ((1 << width) - 1) << low
                        shift = low

                lines.append(f"#define {field_name}_MASK   0x{mask:08X}")
                lines.append(f"#define {field_name}_SHIFT  {shift}")
        lines.append("")

        # Command mode enums
        lines.append("/* Command Modes (CMD_CFG.MODE) */")
        lines.append("#define AI_TILE_MODE_MEMCOPY       0x0")
        lines.append("#define AI_TILE_MODE_SNN_INFER     0x1")
        lines.append("#define AI_TILE_MODE_TOPOLOGICAL   0x2")
        lines.append("")

        # Precision enums
        lines.append("/* Precision Modes (CMD_CFG.PRECISION) */")
        lines.append("#define AI_TILE_PRECISION_INT8     0x0")
        lines.append("#define AI_TILE_PRECISION_INT16    0x1")
        lines.append("#define AI_TILE_PRECISION_FP16     0x2")
        lines.append("#define AI_TILE_PRECISION_FP32     0x3")
        lines.append("")

        # Error codes
        lines.append("/* Error Codes (ERROR_CODE.CODE) */")
        lines.append("#define AI_TILE_ERR_NONE           0x00")
        lines.append("#define AI_TILE_ERR_INVALID_ADDR   0x01")
        lines.append("#define AI_TILE_ERR_ALIGNMENT      0x02")
        lines.append("#define AI_TILE_ERR_DDR_NOT_READY  0x03")
        lines.append("#define AI_TILE_ERR_INVALID_MODE   0x04")
        lines.append("#define AI_TILE_ERR_TIMEOUT        0x05")
        lines.append("#define AI_TILE_ERR_DMA            0x06")
        lines.append("")

        # Helper macros
        lines.append("/* Helper Macros */")
        lines.append("#define AI_TILE_READ32(base, offset) \\")
        lines.append("    (*(volatile uint32_t*)((uintptr_t)(base) + (offset)))")
        lines.append("")
        lines.append("#define AI_TILE_WRITE32(base, offset, value) \\")
        lines.append("    (*(volatile uint32_t*)((uintptr_t)(base) + (offset)) = (value))")
        lines.append("")
        lines.append("#define AI_TILE_SET_FIELD(value, field_mask, field_shift, field_value) \\")
        lines.append("    (((value) & ~(field_mask)) | (((field_value) << (field_shift)) & (field_mask)))")
        lines.append("")
        lines.append("#define AI_TILE_GET_FIELD(value, field_mask, field_shift) \\")
        lines.append("    (((value) & (field_mask)) >> (field_shift))")
        lines.append("")

        # Footer
        lines.append(f"#endif /* {guard} */")
        lines.append("")

        return '\n'.join(lines)

    def generate_markdown(self) -> str:
        """Generate Markdown documentation"""
        lines = []

        # Title
        lines.append("# AI Tile Register Map")
        lines.append("")
        lines.append("**Auto-generated documentation**")
        lines.append("")
        lines.append(f"- **Generated**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        lines.append(f"- **Source**: `ai_tile_registers.yaml` v{self.metadata['version']}")
        lines.append(f"- **Description**: {self.metadata['description']}")
        lines.append(f"- **License**: {self.metadata['license']}")
        lines.append("")
        lines.append("---")
        lines.append("")

        # Overview
        lines.append("## Overview")
        lines.append("")
        lines.append(f"The AI tile exposes a **{self.address_space['size']}-byte** register space via PCIe BAR{self.address_space['bar']}.")
        lines.append("All registers are **32-bit** and **word-aligned** (4-byte boundaries).")
        lines.append("")

        # Register summary table
        lines.append("## Register Summary")
        lines.append("")
        lines.append("| Offset | Name | Access | Description |")
        lines.append("|--------|------|--------|-------------|")
        for reg in self.registers:
            lines.append(f"| 0x{reg['offset']:04X} | {reg['name']} | {reg['access']} | {reg['description']} |")
        lines.append("")

        # Detailed register descriptions
        lines.append("## Detailed Register Descriptions")
        lines.append("")

        for reg in self.registers:
            lines.append(f"### {reg['name']} (0x{reg['offset']:04X})")
            lines.append("")
            lines.append(f"**{reg['description']}**")
            lines.append("")
            lines.append(f"- **Access**: {reg['access']}")
            lines.append(f"- **Reset Value**: 0x{reg['reset_value']:08X}")
            lines.append("")

            # Field table
            lines.append("| Bits | Field | Access | Reset | Description |")
            lines.append("|------|-------|--------|-------|-------------|")
            for field in reg['fields']:
                bits = field['bits']
                if isinstance(bits, list):
                    if len(bits) == 1:
                        bit_str = f"[{bits[0]}]"
                    else:
                        bit_str = f"[{bits[0]}:{bits[1]}]"
                # Escape pipe characters in description
                desc_escaped = field['description'].replace('|', '\\|')
                lines.append(f"| {bit_str} | {field['name']} | {field['access']} | {field['reset_value']} | {desc_escaped} |")
            lines.append("")

        # Command sequences
        if self.command_sequences:
            lines.append("## Command Sequences")
            lines.append("")
            for seq in self.command_sequences:
                lines.append(f"### {seq['name'].replace('_', ' ').title()}")
                lines.append("")
                lines.append(seq['description'])
                lines.append("")
                for i, step in enumerate(seq['steps'], 1):
                    lines.append(f"{i}. {step['action']}")
                lines.append("")

        # Validation rules
        if self.validation:
            lines.append("## Validation Rules")
            lines.append("")
            for rule in self.validation:
                lines.append(f"- {rule['rule']}")
            lines.append("")

        # Footer
        lines.append("---")
        lines.append("")
        lines.append("*This document is auto-generated. Do not edit manually.*")
        lines.append("")

        return '\n'.join(lines)


def main():
    parser = argparse.ArgumentParser(
        description='Generate RTL, C headers, and docs from YAML register spec'
    )
    parser.add_argument(
        '--output-dir',
        type=Path,
        default=Path(__file__).parent.parent,
        help='Output base directory (default: project root)'
    )
    args = parser.parse_args()

    # Find YAML spec (in same directory as this script)
    spec_path = Path(__file__).parent / 'ai_tile_registers.yaml'
    if not spec_path.exists():
        print(f"ERROR: Register specification not found: {spec_path}")
        return 1

    # Generate code
    generator = RegisterCodeGenerator(spec_path)
    generator.generate_all(args.output_dir)

    return 0


if __name__ == '__main__':
    exit(main())
