//
// AI Tile Control/Status Registers (auto-generated)
//
// Generated: 2025-11-24 15:07:51
// Source: ai_tile_registers.yaml v1.0.0
// License: BSD-3-Clause
//
// DO NOT EDIT THIS FILE MANUALLY!
// All changes must be made to the YAML specification.
//

module ai_csr (
    // Clock and reset
    input  wire        clk,
    input  wire        rst_n,

    // Avalon-MM slave interface
    input  wire [11:0] avs_address,
    input  wire        avs_write,
    input  wire        avs_read,
    input  wire [31:0] avs_writedata,
    output reg  [31:0] avs_readdata,
    output wire        avs_waitrequest,

    // Status inputs from AI core
    input  wire        core_busy,
    input  wire        core_done,
    input  wire        core_error,
    input  wire        ddr_ready,
    input  wire [7:0]  error_code_in,
    input  wire [31:0] perf_cycles_in,
    input  wire [31:0] ddr_bandwidth_in,
    input  wire [15:0] temperature_in,

    // Control outputs to AI core
    output reg         cmd_start,
    output reg         cmd_reset,
    output reg         cmd_abort,
    output reg  [63:0] cmd_src_addr,
    output reg  [63:0] cmd_dst_addr,
    output reg  [31:0] cmd_length,
    output reg  [31:0] cmd_config,
    output reg  [31:0] snn_threshold,
    output reg  [31:0] snn_leak,
    output reg  [15:0] snn_refract
);

    assign avs_waitrequest = 1'b0;

    // Register storage
    reg [31:0] ctrl_reg;
    reg [31:0] status_reg;
    reg [31:0] cmd_src_lo_reg;
    reg [31:0] cmd_src_hi_reg;
    reg [31:0] cmd_dst_lo_reg;
    reg [31:0] cmd_dst_hi_reg;
    reg [31:0] cmd_len_reg;
    reg [31:0] cmd_cfg_reg;
    reg [31:0] version_reg;
    reg [31:0] capabilities_reg;
    reg [31:0] snn_threshold_reg;
    reg [31:0] snn_leak_reg;
    reg [31:0] snn_refract_reg;
    reg [31:0] error_code_reg;
    reg [31:0] perf_cycles_reg;
    reg [31:0] ddr_bandwidth_reg;
    reg [31:0] temperature_reg;
    reg [31:0] scratch_reg;

    // Write logic
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            // Reset all writable registers
            ctrl_reg <= 32'h00000000;
            cmd_src_lo_reg <= 32'h00000000;
            cmd_src_hi_reg <= 32'h00000000;
            cmd_dst_lo_reg <= 32'h00000000;
            cmd_dst_hi_reg <= 32'h00000000;
            cmd_len_reg <= 32'h00000000;
            cmd_cfg_reg <= 32'h00000000;
            snn_threshold_reg <= 32'h00010000;
            snn_leak_reg <= 32'h00000100;
            snn_refract_reg <= 32'h00000008;
            scratch_reg <= 32'h00000000;
        end else begin
            // Self-clearing bits
            cmd_start <= 1'b0;
            cmd_reset <= 1'b0;
            cmd_abort <= 1'b0;

            if (avs_write) begin
                case (avs_address[11:2])  // Word-aligned
                    10'd0: ctrl_reg <= avs_writedata;
                    10'd2: cmd_src_lo_reg <= avs_writedata;
                    10'd3: cmd_src_hi_reg <= avs_writedata;
                    10'd4: cmd_dst_lo_reg <= avs_writedata;
                    10'd5: cmd_dst_hi_reg <= avs_writedata;
                    10'd6: cmd_len_reg <= avs_writedata;
                    10'd7: cmd_cfg_reg <= avs_writedata;
                    10'd10: snn_threshold_reg <= avs_writedata;
                    10'd11: snn_leak_reg <= avs_writedata;
                    10'd12: snn_refract_reg <= avs_writedata;
                    10'd17: scratch_reg <= avs_writedata;
                    default: ;
                endcase
            end
        end
    end

    // Read logic
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            avs_readdata <= 32'h0;
        end else if (avs_read) begin
            case (avs_address[11:2])
                10'd0: avs_readdata <= ctrl_reg;
                10'd1: avs_readdata <= {
                    26'b0,
                    1'b0,          // THERMAL_WARNING
                    ddr_ready,     // DDR_READY
                    1'b0,          // IRQ_PENDING
                    core_error,    // ERROR
                    core_done,     // DONE
                    core_busy      // BUSY
                };
                10'd2: avs_readdata <= cmd_src_lo_reg;
                10'd3: avs_readdata <= cmd_src_hi_reg;
                10'd4: avs_readdata <= cmd_dst_lo_reg;
                10'd5: avs_readdata <= cmd_dst_hi_reg;
                10'd6: avs_readdata <= cmd_len_reg;
                10'd7: avs_readdata <= cmd_cfg_reg;
                10'd8: avs_readdata <= 32'h01000000;  // Version
                10'd9: avs_readdata <= 32'h00000003;  // Capabilities
                10'd10: avs_readdata <= snn_threshold_reg;
                10'd11: avs_readdata <= snn_leak_reg;
                10'd12: avs_readdata <= snn_refract_reg;
                10'd13: avs_readdata <= {24'b0, error_code_in};
                10'd14: avs_readdata <= perf_cycles_in;
                10'd15: avs_readdata <= ddr_bandwidth_in;
                10'd16: avs_readdata <= {16'b0, temperature_in};
                10'd17: avs_readdata <= scratch_reg;
                default: avs_readdata <= 32'hDEADBEEF;
            endcase
        end
    end

    // Output assignments
    always @(*) begin
        cmd_start = avs_write && (avs_address[11:2] == 10'd0) && avs_writedata[0];
        cmd_reset = avs_write && (avs_address[11:2] == 10'd0) && avs_writedata[1];
        cmd_abort = avs_write && (avs_address[11:2] == 10'd0) && avs_writedata[3];
        cmd_src_addr = {cmd_src_hi_reg, cmd_src_lo_reg};
        cmd_dst_addr = {cmd_dst_hi_reg, cmd_dst_lo_reg};
        cmd_length = cmd_len_reg;
        cmd_config = cmd_cfg_reg;
        snn_threshold = snn_threshold_reg;
        snn_leak = snn_leak_reg;
        snn_refract = snn_refract_reg[15:0];
    end

endmodule
