#!/usr/bin/env python3
"""
Generate Quartus .qsf constraints from board YAML specification

Usage:
    python gen_qsf.py <board_yaml> <output_qsf>

Example:
    python gen_qsf.py ../../specs/boards/a10ped_board.yaml build/project.qsf

Author: Quanta Hardware Project
License: MIT
"""

import sys
import yaml
from pathlib import Path


def generate_qsf_header(board):
    """Generate QSF file header"""
    lines = [
        "#",
        "# Quartus Settings File (Auto-generated)",
        "#",
        f"# Board: {board['board_name']}",
        f"# Part: {board['fpga_part']}",
        f"# Revision: {board.get('revision', 'unknown')}",
        "#",
        "# DO NOT EDIT THIS FILE MANUALLY!",
        "# All changes should be made to the board YAML specification.",
        "#",
        "",
    ]
    return lines


def generate_device_settings(board):
    """Generate device and family settings"""
    lines = [
        "# Device Settings",
        f'set_global_assignment -name DEVICE {board["fpga_part"]}',
        f'set_global_assignment -name FAMILY "{board["vendor"].title()}"',
        "",
    ]
    return lines


def generate_pcie_constraints(pcie_config):
    """Generate PCIe pin constraints"""
    lines = [
        "# ==================================================",
        "# PCIe Configuration",
        "# ==================================================",
        "",
        "# PCIe Reference Clock",
        f'set_location_assignment {pcie_config["refclk_pin"]} -to pcie_refclk',
        'set_instance_assignment -name IO_STANDARD HCSL -to pcie_refclk',
        f'# Frequency: {pcie_config["refclk_freq_mhz"]} MHz',
        "",
        "# PCIe Reset (Active Low)",
        f'set_location_assignment {pcie_config["reset_pin"]} -to pcie_perst_n',
        'set_instance_assignment -name IO_STANDARD "1.8 V" -to pcie_perst_n',
        "",
    ]

    # PCIe lanes (SerDes pins are typically managed by HIP IP)
    lines.append("# PCIe Lanes (SerDes - managed by Hard IP)")
    for lane_info in pcie_config["lane_pins"]:
        lane = lane_info["lane"]
        lines.append(f"# Lane {lane}:")
        lines.append(f"#   TX: {lane_info['tx_p']} (p), {lane_info['tx_n']} (n)")
        lines.append(f"#   RX: {lane_info['rx_p']} (p), {lane_info['rx_n']} (n)")

    lines.append("")
    return lines


def generate_clock_constraints(clocks):
    """Generate clock pin constraints"""
    lines = [
        "# ==================================================",
        "# Board Clocks",
        "# ==================================================",
        "",
    ]

    for clk in clocks:
        lines.append(f'# {clk["name"]} - {clk["freq_mhz"]} MHz')
        lines.append(f'set_location_assignment {clk["pin"]} -to {clk["name"]}')

        io_std = clk.get("io_standard", "1.8 V")
        lines.append(f'set_instance_assignment -name IO_STANDARD "{io_std}" -to {clk["name"]}')

        if clk.get("is_diff", False):
            lines.append(f'# Differential clock pair')

        lines.append("")

    return lines


def generate_memory_constraints(memory_config):
    """Generate DDR4 memory constraints"""
    lines = [
        "# ==================================================",
        "# DDR4 Memory",
        "# ==================================================",
        "",
    ]

    if "ddr4" in memory_config:
        for ctrl in memory_config["ddr4"]["controllers"]:
            lines.append(f'# Controller: {ctrl["name"]}')
            lines.append(f'# Bank Group: {ctrl["bank_group"]}')
            lines.append(f'# Interface Width: {ctrl["interface_width"]} bits')

            # Check if pins file exists
            pins_file = Path(ctrl["pins_file"])
            if pins_file.exists():
                lines.append(f'# Pin assignments loaded from: {ctrl["pins_file"]}')
                lines.append(f'source {ctrl["pins_file"]}')
            else:
                lines.append(f'# WARNING: Pin file not found: {ctrl["pins_file"]}')
                lines.append(f'# DDR4 pins must be assigned manually or via EMIF IP')

            lines.append("")

    return lines


def generate_misc_io_constraints(ios):
    """Generate miscellaneous IO constraints"""
    lines = [
        "# ==================================================",
        "# Miscellaneous IOs",
        "# ==================================================",
        "",
    ]

    # Group by role
    by_role = {}
    for io in ios:
        role = io.get("role", "general")
        if role not in by_role:
            by_role[role] = []
        by_role[role].append(io)

    for role, io_list in by_role.items():
        lines.append(f"# {role.replace('_', ' ').title()}")
        for io in io_list:
            lines.append(f'set_location_assignment {io["pin"]} -to {io["name"]}')
            lines.append(f'set_instance_assignment -name IO_STANDARD "{io["io_standard"]}" -to {io["name"]}')

            if io["direction"] == "output":
                lines.append(f'# Output')
            elif io["direction"] == "input":
                lines.append(f'# Input')

        lines.append("")

    return lines


def generate_jtag_constraints(jtag_config):
    """Generate JTAG constraints"""
    lines = [
        "# ==================================================",
        "# JTAG Configuration",
        "# ==================================================",
        "",
        f'# Interface: {jtag_config.get("interface", "unknown")}',
        f'set_location_assignment {jtag_config["tck_pin"]} -to altera_reserved_tck',
        f'set_location_assignment {jtag_config["tms_pin"]} -to altera_reserved_tms',
        f'set_location_assignment {jtag_config["tdi_pin"]} -to altera_reserved_tdi',
        f'set_location_assignment {jtag_config["tdo_pin"]} -to altera_reserved_tdo',
        "",
    ]
    return lines


def generate_qsf(board_yaml_path, output_qsf_path):
    """Main function to generate .qsf file"""
    # Load board specification
    with open(board_yaml_path, 'r') as f:
        board = yaml.safe_load(f)

    # Generate all sections
    all_lines = []
    all_lines.extend(generate_qsf_header(board))
    all_lines.extend(generate_device_settings(board))
    all_lines.extend(generate_pcie_constraints(board["pcie"]))
    all_lines.extend(generate_clock_constraints(board.get("clocks", [])))
    all_lines.extend(generate_memory_constraints(board.get("memory", {})))
    all_lines.extend(generate_misc_io_constraints(board.get("misc_ios", [])))

    if "jtag" in board:
        all_lines.extend(generate_jtag_constraints(board["jtag"]))

    # Write output
    output_path = Path(output_qsf_path)
    output_path.parent.mkdir(parents=True, exist_ok=True)

    with open(output_path, 'w') as f:
        f.write('\n'.join(all_lines))

    print(f"✅ Generated Quartus constraints: {output_qsf_path}")
    print(f"   - {len(board.get('pcie', {}).get('lane_pins', []))} PCIe lanes")
    print(f"   - {len(board.get('clocks', []))} clock inputs")
    print(f"   - {len(board.get('misc_ios', []))} misc IOs")


def main():
    """Main entry point"""
    if len(sys.argv) != 3:
        print("Usage: gen_qsf.py <board_yaml> <output_qsf>")
        print("")
        print("Example:")
        print("  python gen_qsf.py specs/boards/a10ped_board.yaml out/build/project.qsf")
        sys.exit(1)

    board_yaml = sys.argv[1]
    output_qsf = sys.argv[2]

    try:
        generate_qsf(board_yaml, output_qsf)
    except FileNotFoundError as e:
        print(f"❌ Error: {e}")
        sys.exit(1)
    except KeyError as e:
        print(f"❌ Error: Missing required field in YAML: {e}")
        sys.exit(1)
    except Exception as e:
        print(f"❌ Unexpected error: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    main()
