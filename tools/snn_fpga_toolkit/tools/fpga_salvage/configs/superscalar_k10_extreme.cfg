# OpenOCD Configuration for Superscalar K10 / COL Engine P2 (EXTREME TIER)
#
# Board: Superscalar K10 or COL Engine P2 (K10+)
# FPGA: UNKNOWN - Likely Xilinx VU37P, Intel Stratix 10 GX2800, or Agilex 7 AGF027
# Power: 1700W - 1800W TDP (!!!)
# Interface: Gigabit Ethernet (primary), Latent PCIe lanes (must be activated)
# Algorithms: kHeavyHash (Kaspa), Blake3, Sha512256D, Ironfish
#
# âš ï¸  EXTREME DIFFICULTY WARNING âš ï¸
# This is NOT a beginner-friendly salvage target!
#
# Requirements:
#   - Advanced reverse engineering skills (JTAG exploitation, flash dumping)
#   - Industrial power infrastructure (dual 1200W server PSUs + sync BoB)
#   - High-amperage 16AWG cabling (140A+ on 12V rail)
#   - Comprehensive thermal management (1700W heat dissipation!)
#   - Acceptance of hardware destruction risk
#
# This config is a TEMPLATE - you MUST reverse engineer the actual pinout!
#
# Author: FPGA Salvage Project - Extreme Tier
# Date: 2024
# License: GPL-3.0

# ============================================================================
# SECURITY NOTICE
# ============================================================================

# K10/P2 devices employ ACTIVE SECURITY MEASURES:
#
# K10 (Original):
#   - External SD card for config (relatively accessible)
#   - Bootloader can be intercepted/modified
#   - Risk: Medium
#
# COL Engine P2 (K10+):
#   - Internal flash chip (requires physical access)
#   - Possible bootloader encryption
#   - Possible JTAG disable fuses (check before proceeding!)
#   - Risk: HIGH
#
# This config assumes you have ALREADY:
# 1. Identified JTAG header via electrical probing (oscilloscope + Jtagulator)
# 2. Defeated any JTAG lockout (fuse check, voltage glitching, etc.)
# 3. Successfully read FPGA IDCODE via scan_chain
#
# IF YOU HAVE NOT DONE THIS, DO NOT PROCEED!

# ============================================================================
# JTAG Adapter Configuration
# ============================================================================

# Use high-quality JTAG adapter for reliable connection
# Recommended: SEGGER J-Link, Bus Blaster v3, or FTDI FT2232H

adapter driver ftdi
ftdi_vid_pid 0x0403 0x6010  # FTDI FT2232H
ftdi_layout_init 0x0008 0x000b

# JTAG clock - Start SLOW for initial probing
adapter speed 100  # 100 kHz - increase to 1MHz after stable connection

# Reset config - Unknown, may require active SRST
reset_config srst_only srst_push_pull

# ============================================================================
# STEP 1: JTAG Header Discovery (YOU MUST DO THIS FIRST!)
# ============================================================================

# The K10/P2 does NOT have a labeled JTAG header
# You must locate it via:
#
# 1. Visual inspection:
#    - Look for unpopulated 2x5 or 2x7 0.1" pitch header
#    - Often near edge of board or near FPGA
#    - May have silkscreen: J1, J2, JTAG, DEBUG, TEST
#
# 2. Electrical probing with Jtagulator:
#    - Connect Jtagulator to suspected pins
#    - Run IDCODE scan: jtagulator> i
#    - Look for valid FPGA IDCODE response
#
# 3. Oscilloscope verification:
#    - TCK should show clock activity during boot
#    - TMS should show state machine transitions
#    - TDI/TDO should show serial data
#
# 4. Pinout (standard but VERIFY for your board):
#    Pin 1: VREF (3.3V or 1.8V - measure with DMM)
#    Pin 2: GND
#    Pin 3: TCK (Test Clock)
#    Pin 4: GND
#    Pin 5: TDI (Test Data In)
#    Pin 6: GND
#    Pin 7: TMS (Test Mode Select)
#    Pin 8: GND
#    Pin 9: TDO (Test Data Out)
#    Pin 10: GND

# ============================================================================
# STEP 2: FPGA Identification (MUST BE DETERMINED)
# ============================================================================

# Once JTAG is connected, run:
# openocd -f this_config.cfg -c "init; scan_chain; shutdown"
#
# This will reveal the ACTUAL FPGA IDCODE
# Then uncomment the correct section below:

# --- Option A: Xilinx Virtex UltraScale+ VU37P ---
# (Most likely if board is 2023+ and Xilinx-based)
# jtag newtap virtex tap -irlen 6 -expected-id 0x14B51093

# --- Option B: Intel Stratix 10 GX2800 ---
# (Most likely if board is Intel-based, high-end)
# jtag newtap stratix10 tap -irlen 10 -expected-id 0x02D020DD

# --- Option C: Intel Agilex 7 AGF027 ---
# (Possible if board is 2022+, cutting-edge)
# jtag newtap agilex tap -irlen 10 -expected-id 0x02E320DD

# --- Option D: Unknown / Custom FPGA ---
# If IDCODE doesn't match known devices, you may have:
# - Engineering sample (different IDCODE)
# - Custom ASIC (not reprogrammable - project ends here!)
# - Multi-chip module (multiple IDCODEs in chain)
#
# Record ACTUAL IDCODE and search:
#   - Xilinx device database: https://www.xilinx.com/support/
#   - Intel device database: https://www.intel.com/programmable/
#   - Community forums: Reddit r/FPGA, EEVBlog

# ============================================================================
# STEP 3: Boundary Scan I/O Mapping (CRITICAL FOR AI CONVERSION)
# ============================================================================

# Once FPGA is identified, use boundary scan to map I/O:
#
# 1. DDR Memory Interface:
#    - Critical for AI model storage
#    - Expect DDR4-3200, 4-8GB per channel
#    - kHeavyHash is memory-hard (confirms high-bandwidth DDR)
#
# 2. Latent PCIe Transceivers:
#    - K10/P2 uses Ethernet, but high-end FPGA likely has PCIe capability
#    - Look for unused GTH/GTY (Xilinx) or XCVR (Intel) pins
#    - May need to solder PCIe edge connector to access
#
# 3. Power Management (EXTREMELY CRITICAL):
#    - 1700W means complex power delivery with multiple rails
#    - Identify I2C/PMBus lines to PMIC (e.g., LTC2972, TPS53647)
#    - MUST replicate power sequencing in custom bitstream
#    - Failure = instant FPGA burnout!
#
# 4. Thermal Management:
#    - Fan PWM control lines
#    - Temperature sensor I2C (likely TMP451 or similar)
#    - Custom bitstream MUST control fans based on temp
#    - 1700W with failed cooling = fire hazard

# Boundary scan command sequence (via telnet to port 4444):
# > init
# > scan_chain
# > irscan [fpga_name].tap 0x00E  # EXTEST
# > drscan [fpga_name].tap 8192 0 # Read all boundary scan cells
# > shutdown
#
# Save output, analyze with scripting to map:
# - Which pins are inputs/outputs
# - Which pins are at 3.3V, 1.8V, 1.2V (I/O bank voltage)
# - Which pins show activity (clock signals, data buses)

# ============================================================================
# STEP 4: Flash Memory Dump (REQUIRED FOR BOOTLOADER ANALYSIS)
# ============================================================================

# K10 (SD Card):
#   - Remove SD card from slot
#   - Read with SD card reader on PC
#   - Analyze filesystem (likely ext4 or custom)
#   - Locate bitstream file (*.sof, *.bit, *.bin)
#   - Locate bootloader (u-boot or custom)
#
# P2 (Internal Flash):
#   - Locate flash chip on board (likely QSPI, 128-256 Mb)
#   - Option A: SOIC clip method
#     * Use SOIC-8 clip on flash chip
#     * Connect to external programmer (CH341A, Bus Pirate)
#     * Dump full flash contents
#   - Option B: JTAG flash access
#     * Use FPGA's JTAG to read flash via SPI bridge
#     * Requires knowing flash memory map (reverse engineer from PCB)
#   - Option C: Runtime extraction
#     * Boot system normally
#     * Use JTAG to dump FPGA configuration RAM after boot
#     * Not as clean as direct flash dump

# OpenOCD flash dump (if flash memory map is known):
# > init
# > flash read_bank 0 factory_dump.bin 0x0 0x10000000
# > shutdown

# ============================================================================
# STEP 5: Bootloader Exploitation (ENABLES CUSTOM BITSTREAM)
# ============================================================================

# Analyze dumped bootloader with:
#   - Ghidra (https://ghidra-sre.org/) - free reverse engineering tool
#   - IDA Pro - commercial alternative
#   - binwalk - identify embedded filesystems and firmware
#
# Goal: Find bitstream load address and modify to point to custom bitstream
#
# Common exploit vectors:
#   1. Bootloader argument injection (if u-boot)
#   2. Flash partition table modification
#   3. Checksum bypass (if firmware validation is weak)
#   4. JTAG bootloader override (force load from JTAG instead of flash)

# ============================================================================
# STEP 6: Power Delivery System (MANDATORY BEFORE TESTING)
# ============================================================================

# DO NOT power K10/P2 with standard ATX PSU!
# You need INDUSTRIAL SETUP:
#
# Parts Required:
#   - 2x Server PSU (HP 1200W Platinum, Delta 1200W, etc.)
#     * MUST support 200-240V input for full power
#     * 80 Plus Platinum efficiency minimum
#   - 1x PSU Breakout Board with Chain Sync (X11, ZSX)
#     * Synchronizes multiple PSUs
#     * Provides 16+ PCIe 6-pin outputs
#   - Heavy gauge cables (16AWG minimum, 14AWG recommended)
#     * Each cable rated 10A+ (120W on 12V)
#     * Use multiple cables in parallel for 1700W load
#   - High-amperage connections
#     * Solder or crimp all connections (NO friction fit!)
#     * Verify with multimeter before powering on
#
# Power-On Sequence (CRITICAL):
#   1. Verify all cables secure
#   2. Enable PSU sync (Chain Sync switch on BoB)
#   3. Power on PSUs (should start simultaneously)
#   4. Monitor 12V rail voltage (should be 11.8-12.2V under load)
#   5. Watch for smoke, burning smell, or excessive heat
#   6. If any issues: POWER OFF IMMEDIATELY

# Failure modes:
#   - Undervoltage: PSUs shutdown (insufficient wattage or bad cables)
#   - Overcurrent: Circuit breaker trips (check wall outlet rating)
#   - Thermal: Components overheat (failed cooling or bad thermal paste)

# ============================================================================
# STEP 7: Custom Bitstream Compilation (AI ACCELERATION LOGIC)
# ============================================================================

# Once reverse engineering is complete, compile AI bitstream:
#
# For Xilinx VU37P:
#   - Use Vivado 2023.2+
#   - Implement PCIe Hard IP (x8 Gen3) if PCIe pins identified
#   - Implement DDR4 memory controller (use mapped pinout)
#   - Add AI logic (CNN, Transformer, etc. - see examples/)
#   - Critical: Include power management and thermal control!
#
# For Intel Stratix 10 / Agilex:
#   - Use Quartus Prime Pro 23.4+
#   - Implement PCIe Hard IP
#   - Implement EMIF (External Memory Interface) for DDR4
#   - Add AI OpenCL kernels or custom RTL
#   - Critical: Replicate power sequencing from factory bitstream!

# Bitstream safety checklist:
#   [ ] All I/O voltages match boundary scan data
#   [ ] DDR4 memory timing parameters verified
#   [ ] Power sequencing logic implemented
#   [ ] Fan control PWM configured (thermal protection)
#   [ ] Temperature monitoring enabled
#   [ ] PCIe link training tested (if using PCIe)
#   [ ] Current limiting on power rails (if possible)

# ============================================================================
# STEP 8: Initial Testing (HIGH RISK PHASE)
# ============================================================================

# First power-on with custom bitstream:
#
# 1. Minimal config test:
#    - Load bitstream with ONLY power sequencing + fan control
#    - No AI logic yet (minimize power draw)
#    - Monitor temps, voltages, currents via JTAG/I2C
#    - Target: <500W power draw for minimal config
#
# 2. Memory test:
#    - Add DDR4 controller to bitstream
#    - Run memtest pattern (write/read/verify)
#    - Verify data integrity at full bandwidth
#    - Target: 50+ GB/s aggregate bandwidth
#
# 3. PCIe test (if activated):
#    - Load bitstream with PCIe endpoint
#    - Check host detection: lspci | grep -i fpga
#    - Test DMA transfers (small packets first)
#    - Target: 6 GB/s (x8 Gen3 theoretical)
#
# 4. Thermal stress test:
#    - Load bitstream with AI logic (initially low utilization)
#    - Gradually increase compute intensity
#    - Monitor temps continuously (must stay <95Â°C junction)
#    - Target: Stable operation at 1700W for 1 hour

# ============================================================================
# TROUBLESHOOTING
# ============================================================================

# Issue: JTAG scan_chain returns no devices
# Fix:
#   - Verify VREF voltage (3.3V or 1.8V at JTAG pin 1)
#   - Check GND continuity
#   - Try slower speed: adapter speed 10
#   - Possible JTAG fuses blown (check with vendor docs)

# Issue: Bitstream loads but FPGA doesn't configure
# Fix:
#   - Check configuration mode (JTAG vs Flash)
#   - Verify bitstream is for correct FPGA variant
#   - Check INIT_B and DONE signals via boundary scan

# Issue: Power supply shuts down immediately
# Fix:
#   - Reduce cable count (limit inrush current)
#   - Check for shorts (use continuity tester)
#   - Verify PSU can handle 1700W (two 1200W PSUs required)

# Issue: FPGA overheats
# Fix:
#   - Verify fan PWM control in bitstream
#   - Check thermal paste application
#   - Ensure all heatsinks properly mounted
#   - Reduce clock frequency or logic utilization

# Issue: DDR4 memory fails tests
# Fix:
#   - Verify pinout mapping (use boundary scan)
#   - Check memory timing parameters (consult FPGA manual)
#   - Test one channel at a time to isolate bad DIMMs

# ============================================================================
# EXPECTED AI PERFORMANCE (IF SUCCESSFUL)
# ============================================================================

# Based on estimated FPGA specs:
#
# VU37P (Xilinx):
#   - Logic Cells: 4.4M
#   - DSP Slices: 5,952
#   - Memory: 108 Mb BRAM
#   - Estimated AI: 15-25 TOPS INT8 (CNN inference)
#   - Power efficiency: 68-113 GOPS/W
#
# Stratix 10 GX2800 (Intel):
#   - Logic Elements: 2.8M
#   - DSP Blocks: 5,760
#   - Memory: 229 Mb M20K
#   - Estimated AI: 12-20 TOPS INT8
#   - Power efficiency: 60-100 GOPS/W
#
# Agilex 7 AGF027 (Intel):
#   - Logic Elements: 2.7M
#   - DSP Blocks: 14,000 (!!!)
#   - Memory: 256 Mb M20K
#   - Estimated AI: 25-40 TOPS INT8
#   - Power efficiency: 125-200 GOPS/W (best case)

# Compare to commodity hardware:
#   - NVIDIA A100: 624 TOPS INT8, 400W (1,560 GOPS/W) - Still better!
#   - BUT: A100 costs $10,000+, K10/P2 might be $2,000-5,000 used

# The value proposition:
#   - IF you have the skills to salvage K10/P2
#   - AND you need high-density FPGA compute
#   - THEN this can be 3-5x cheaper than buying new high-end FPGA board
#   - BUT: Requires 100+ hours of reverse engineering work

# ============================================================================
# FINAL WARNING
# ============================================================================

# This project is NOT for beginners!
# Risk of:
#   - Hardware destruction ($2,000-5,000 loss)
#   - Electrical hazards (1700W, 140A)
#   - Fire risk (improper cooling)
#   - Wasted time (months of reverse engineering)
#
# Only proceed if you have:
#   âœ“ Advanced FPGA experience
#   âœ“ Electrical engineering background
#   âœ“ Reverse engineering skills
#   âœ“ Proper lab equipment (scope, logic analyzer, etc.)
#   âœ“ Industrial power infrastructure
#   âœ“ Financial cushion to absorb potential loss
#   âœ“ Acceptance of failure risk

# For most users, stick with:
#   - 4x Agilex hashboards ($400, well-documented)
#   - VU35P PCIe cards ($800, easy to salvage)
#   - BittWare A10PED ($1,500, fully supported)

# ============================================================================
# COMMUNITY SUPPORT
# ============================================================================

# If you successfully salvage a K10/P2:
#   - PLEASE share your findings on GitHub!
#   - Document your pinout, power sequencing, thermal solution
#   - Help future researchers avoid starting from scratch
#   - You will be featured in the Hall of Fame!

# Join our Discord: #extreme-tier-salvage channel
# Post on GitHub: Issues with [K10] or [P2] tag

# Good luck, and stay safe! âš¡ðŸ”¥

# ============================================================================
# End of Configuration
# ============================================================================
